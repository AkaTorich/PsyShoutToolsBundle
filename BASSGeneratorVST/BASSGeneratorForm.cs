using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using NAudio.Midi;

namespace BASSGeneratorVST
{
    public partial class BASSGeneratorForm : Form
    {
        private readonly Dictionary<string, Dictionary<string, int[]>> scalesByCategory;
        private BASSGeneratorVstPlugin _plugin;
        private string _lastGeneratedMidiPath;
        
        private readonly Dictionary<string, int> noteOffsets = new Dictionary<string, int>()
        {
            { "C", 0 }, { "C#", 1 }, { "Db", 1 }, { "D", 2 }, { "D#", 3 }, { "Eb", 3 },
            { "E", 4 }, { "F", 5 }, { "F#", 6 }, { "Gb", 6 }, { "G", 7 }, { "G#", 8 },
            { "Ab", 8 }, { "A", 9 }, { "A#", 10 }, { "Bb", 10 }, { "B", 11 },
        };

        // Словарь для хранения названий аккордов и их интервальной структуры
        private readonly Dictionary<string, int[]> chordTypes = new Dictionary<string, int[]>()
        {
            // Основные типы аккордов (трезвучия)
            { "Major", new int[] { 0, 4, 7 } },             // Мажорное трезвучие
            { "Minor", new int[] { 0, 3, 7 } },             // Минорное трезвучие
            { "Diminished", new int[] { 0, 3, 6 } },        // Уменьшенное трезвучие
            { "Augmented", new int[] { 0, 4, 8 } },         // Увеличенное трезвучие
            { "Sus2", new int[] { 0, 2, 7 } },              // Сус2
            { "Sus4", new int[] { 0, 5, 7 } },              // Сус4
            
            // Септаккорды
            { "Major7", new int[] { 0, 4, 7, 11 } },        // Большой мажорный септаккорд
            { "Minor7", new int[] { 0, 3, 7, 10 } },        // Малый минорный септаккорд
            { "Dominant7", new int[] { 0, 4, 7, 10 } },     // Доминантсептаккорд
            { "Diminished7", new int[] { 0, 3, 6, 9 } },    // Уменьшенный септаккорд
            { "Half-Diminished7", new int[] { 0, 3, 6, 10 }}, // Полууменьшенный септаккорд
            { "Minor-Major7", new int[] { 0, 3, 7, 11 } },   // Минорный-мажорный септаккорд
            { "Augmented7", new int[] { 0, 4, 8, 10 } },    // Увеличенный септаккорд
            
            // Аккорды с добавленными ступенями
            { "Add9", new int[] { 0, 4, 7, 14 } },          // Add9
            { "Add11", new int[] { 0, 4, 7, 17 } },         // Add11
            { "Add13", new int[] { 0, 4, 7, 21 } },         // Add13
            { "6", new int[] { 0, 4, 7, 9 } },             // Мажорный с секстой
            { "m6", new int[] { 0, 3, 7, 9 } },            // Минорный с секстой
            
            // Нонаккорды
            { "Major9", new int[] { 0, 4, 7, 11, 14 } },    // Большой мажорный нонаккорд
            { "Minor9", new int[] { 0, 3, 7, 10, 14 } },    // Малый минорный нонаккорд
            { "Dominant9", new int[] { 0, 4, 7, 10, 14 } }, // Доминантнонаккорд
            
            // Ундецимаккорды и терцдецимаккорды
            { "Major11", new int[] { 0, 4, 7, 11, 14, 17 } }, // Большой мажорный ундецимаккорд
            { "Minor11", new int[] { 0, 3, 7, 10, 14, 17 } }, // Малый минорный ундецимаккорд
            { "Dominant11", new int[] { 0, 4, 7, 10, 14, 17 } }, // Доминантундецимаккорд
            { "Major13", new int[] { 0, 4, 7, 11, 14, 17, 21 } }, // Большой мажорный терцдецимаккорд
            { "Minor13", new int[] { 0, 3, 7, 10, 14, 17, 21 } }, // Малый минорный терцдецимаккорд
            { "Dominant13", new int[] { 0, 4, 7, 10, 14, 17, 21 } }, // Доминанттерцдецимаккорд
            
            // Альтерированные аккорды
            { "7b5", new int[] { 0, 4, 6, 10 } },           // Доминантсептаккорд с пониженной квинтой
            { "7#5", new int[] { 0, 4, 8, 10 } },           // Доминантсептаккорд с повышенной квинтой
            { "7b9", new int[] { 0, 4, 7, 10, 13 } },       // Доминантсептаккорд с пониженной ноной
            { "7#9", new int[] { 0, 4, 7, 10, 15 } },       // Доминантсептаккорд с повышенной ноной
            { "7#11", new int[] { 0, 4, 7, 10, 14, 18 } },  // Доминантсептаккорд с повышенной ундецимой
            { "7b13", new int[] { 0, 4, 7, 10, 14, 17, 20 } }, // Доминантсептаккорд с пониженной терцдецимой
            
            // Специальные аккорды
            { "5", new int[] { 0, 7 } },                   // Квинтаккорд (пауэр-аккорд)
            { "Quartal", new int[] { 0, 5, 10 } },          // Квартовый аккорд
            { "Polychord C/G", new int[] { 0, 4, 7, 12, 19 } }, // Полиаккорд C/G
        };

        // Обновленные и расширенные басовые паттерны
private readonly Dictionary<string, int[]> bassPatterns = new Dictionary<string, int[]>()
{
    // Базовые паттерны
    { "Root Note", new int[] { 0 } },                      // Только корневая нота
    { "Root-Fifth", new int[] { 0, 7 } },                  // Корень и квинта
    { "Root-Octave", new int[] { 0, 12 } },                // Корень и октава
    { "Arpeggiated Triad", new int[] { 0, 4, 7 } },        // Арпеджированное трезвучие
    { "Arpeggiated Minor", new int[] { 0, 3, 7 } },        // Арпеджированное минорное трезвучие
    
    // Улучшенные жанровые паттерны
    { "Walking Bass", new int[] { 0, 4, 7, 9, 7, 4, 2, 0 } },  // Расширенный "ходячий бас" с хроматизмами
    { "Boogie", new int[] { 0, 0, 0, 0, 7, 7, 7, 7 } },        // Классический буги-паттерн с повторами
    { "Blues", new int[] { 0, 3, 5, 6, 7, 6, 5, 3 } },         // Блюзовый паттерн с блюзовыми нотами
    
    // Рок и метал
    { "Rock", new int[] { 0, 0, 7, 7, 0, 0, 5, 7 } },           // Классический рок с вариациями
    { "Hard Rock", new int[] { 0, 0, 7, 0, 12, 12, 7, 0 } },    // Хард-рок с октавой
    { "Metal", new int[] { 0, 0, 0, 0, 7, 7, 7, 7, 5, 5, 3, 3, 0, 0, 0, 0 } }, // Метал с пальмом
    { "Thrash Metal", new int[] { 0, 0, 0, 5, 7, 7, 7, 5, 0, 0, 0, 12 } }, // Треш-метал с галопом
    { "Progressive Metal", new int[] { 0, 3, 7, 12, 7, 5, 3, 0, 5, 7, 12, 15 } }, // Прогрессив-метал
    
    // Танцевальная музыка
    { "Funk", new int[] { 0, 7, 10, 7, 12, 10, 7, 5, 4, 5, 7, 5, 0 } }, // Фанковый с шестнадцатыми
    { "R&B", new int[] { 0, 5, 7, 9, 10, 9, 7, 5, 4, 0, 4, 5 } },       // Современный R&B с синкопами
    { "Soul", new int[] { 0, 3, 7, 10, 12, 10, 7, 3, 0, 3, 5, 7 } },    // Соул с мелодическими ходами
    { "Disco", new int[] { 0, 7, 0, 7, 12, 7, 12, 0, 7, 0, 5, 7, 5, 0 } }, // Диско с характерным грувом
    
    // Электронная музыка (улучшенные)
    { "Techno", new int[] { 0, 0, 0, 0, 12, 12, 12, 12, 7, 7, 7, 7, 5, 5, 5, 5 } }, // Техно с акцентами
    { "House", new int[] { 0, 0, 7, 7, 12, 12, 7, 7, 0, 0, 5, 5, 7, 7, 5, 5 } },    // Хаус с четвертями
    { "Trance", new int[] { 0, 4, 7, 12, 7, 4, 0, 0, 5, 9, 12, 9, 5, 0, 0, 0 } },   // Транс с арпеджио
    { "PsyTrance", new int[] { 0, 0, 7, 0, 0, 12, 7, 0, 0, 7, 5, 0, 5, 7, 12, 0 } }, // Пситранс с гейтом
    { "Acid", new int[] { 0, 3, 7, 10, 7, 3, 7, 10, 7, 3, 0, 3, 7, 3, 7, 10 } },     // Кислотная линия
    { "Drum & Bass", new int[] { 0, 0, 7, 0, 5, 0, 12, 0, 7, 0, 5, 7, 5, 0, 12, 5 } }, // DnB с синкопами
    
    // Джаз и блюз
    { "Jazz", new int[] { 0, 4, 7, 11, 9, 7, 5, 4, 2, 0, 11, 9 } },     // Джазовый с расширенной гармонией
    { "Bebop", new int[] { 0, 4, 7, 9, 11, 10, 9, 7, 6, 4, 2, 0 } },   // Бибоп с хроматизмами
    { "Jazz Waltz", new int[] { 0, 7, 4, 7, 12, 9, 7, 4, 0 } },       // Джазовый вальс
    { "Blues Shuffle", new int[] { 0, 0, 3, 5, 6, 5, 3, 0 } },        // Блюзовый шаффл
    
    // Латиноамериканская музыка
    { "Salsa", new int[] { 0, 5, 7, 10, 7, 5, 3, 0, 0, 3, 5, 7, 3, 5, 7, 10 } }, // Сальса с клаве
    { "Bossa Nova", new int[] { 0, 7, 10, 14, 12, 10, 7, 5, 4, 0, 2, 4, 5 } },  // Босса-нова
    { "Samba", new int[] { 0, 7, 10, 7, 3, 0, 3, 7, 10, 7, 3, 0, 7, 10, 12, 14 } }, // Самба с синкопами
    { "Reggae", new int[] { 0, 0, 0, 5, 7, 0, 0, 5, 0, 0, 0, 5, 7, 0, 0, 5 } },    // Регги с дропами
    
    // Фолк и мировая музыка
    { "Celtic", new int[] { 0, 2, 4, 7, 9, 7, 4, 2, 0, 2, 4, 7 } },     // Кельтский фолк
    { "Middle Eastern", new int[] { 0, 1, 4, 5, 7, 5, 4, 1, 0, 1, 4, 5 } }, // Ближневосточный
    { "Indian", new int[] { 0, 5, 7, 10, 12, 10, 7, 5, 0, 5, 7, 10 } }, // Индийский
    { "African", new int[] { 0, 2, 5, 7, 9, 7, 5, 2, 0, 2, 5, 7 } },    // Африканский
    
    // Современные стили
    { "Hip-Hop", new int[] { 0, 7, 0, 12, 0, 7, 5, 3, 0, 7, 12, 7, 0, 5, 3, 0 } }, // Хип-хоп с дропами
    { "Trap", new int[] { 0, 0, 0, 0, 7, 7, 7, 7, 0, 5, 7, 5, 0, 0, 5, 7 } },     // Трэп с восьмыми в триоли
    { "Lo-Fi", new int[] { 0, 3, 5, 7, 10, 7, 5, 3, 0, 3, 5, 7, 5, 3, 0, 0 } },   // Lo-Fi с джазовыми элементами
    { "Future Bass", new int[] { 0, 4, 7, 11, 12, 11, 7, 4, 0, 4, 7, 11, 7, 4, 0, 0 } }, // Future Bass
    
    // Дополнительные электронные стили
    { "Breakbeat", new int[] { 0, 7, 0, 12, 0, 7, 5, 0, 7, 0, 12, 7, 5, 0, 7, 12 } }, // Брейкбит с ломаным ритмом
    { "UK Garage", new int[] { 0, 0, 7, 0, 12, 0, 7, 0, 5, 0, 7, 0, 0, 5, 7, 12 } }, // UK Garage с шаффлом
    { "Dubstep", new int[] { 0, 0, 0, 0, 7, 7, 7, 7, 12, 12, 12, 12, 0, 0, 0, 0 } }, // Дабстеп с вобблом
    { "Glitch Hop", new int[] { 0, 5, 7, 0, 12, 7, 5, 0, 7, 5, 0, 7, 5, 0, 7, 12 } }, // Глитч-хоп с арпеджио
    
    // Транс и электроника с расширенными паттернами
    { "Progressive Trance", new int[] { 0, 0, 7, 7, 12, 12, 7, 0, 0, 7, 12, 12, 7, 7, 5, 0 } },
    { "Goa Trance", new int[] { 0, 5, 7, 0, 7, 5, 0, 12, 7, 5, 3, 0, 3, 5, 7, 12 } },
    { "Uplifting Trance", new int[] { 0, 4, 7, 12, 7, 4, 0, 4, 7, 12, 16, 12, 7, 4, 0, 0 } },
    { "Hard Trance", new int[] { 0, 0, 7, 0, 0, 0, 7, 0, 12, 12, 7, 7, 0, 0, 7, 0 } },
    { "Eurodance", new int[] { 0, 7, 0, 7, 12, 7, 12, 0, 0, 7, 12, 7, 5, 7, 5, 0 } },
    
    // Синтвейв и ретро-электроника
    { "Synthwave", new int[] { 0, 4, 7, 12, 16, 12, 7, 4, 0, 4, 7, 12, 7, 4, 0, 0 } },
    { "Retrowave", new int[] { 0, 7, 12, 7, 0, 7, 12, 16, 12, 7, 0, 7, 5, 0, 5, 7 } },
    { "Outrun", new int[] { 0, 4, 7, 12, 7, 4, 0, 4, 7, 12, 7, 4, 0, 0, 0, 0 } },
    
    // Даунтемпо и чилаут
    { "Downtempo", new int[] { 0, 7, 12, 10, 7, 5, 3, 0, 3, 5, 7, 10, 12, 10, 7, 0 } },
    { "Chillout", new int[] { 0, 5, 7, 12, 14, 12, 7, 5, 0, 5, 7, 5, 0, 0, 7, 12 } },
    { "Trip-Hop", new int[] { 0, 3, 5, 7, 10, 7, 5, 3, 0, 3, 7, 10, 7, 5, 3, 0 } }
};

        // Басовые артикуляции для добавления вариативности
        private readonly Dictionary<string, Func<int, int>> bassArticulations = new Dictionary<string, Func<int, int>>()
        {
            { "Slap", note => note },          // Слэп (без изменения высоты)
            { "Pop", note => note + 12 },      // Поппинг (октава вверх)
            { "Ghost Note", note => -1 },      // Глухая нота (нулевая громкость)
            { "Slide", note => note - 1 },     // Слайд (небольшой спуск)
            { "Hammer-on", note => note + 2 }, // Хаммер (подъем на 2 полутона)
            { "Pull-off", note => note - 2 },  // Пулл-офф (спуск на 2 полутона)
            { "Harmonic", note => note + 12 }, // Флажолет (октава вверх)
            { "Tapping", note => note + 19 },  // Тэппинг (октава + квинта)
        };

        private string lastGeneratedMidiPath = string.Empty;
        private readonly Random random = new Random();

        public BASSGeneratorForm()
        {
            scalesByCategory = InitializeScalesByCategory();
            InitializeComponent();
            InitializeTonicaComboBox();
            InitializeCategoryComboBox();
            InitializeScaleComboBox();
            InitializeBassPatternComboBox();
            SetupTextBoxEvents();
            
            // Кнопка drag-and-drop изначально неактивна
            btnPlayMidi.Enabled = false;

            // Привязываем событие изменения категории
            cmbBoxCategory.SelectedIndexChanged += CmbBoxCategory_SelectedIndexChanged;
        }

        private void SetupTextBoxEvents()
        {
            // Подписываемся на события Enter/Leave для всех TextBox
            foreach (Control control in this.Controls)
            {
                if (control is TextBox textBox)
                {
                    textBox.Enter += TextBox_Enter;
                    textBox.Leave += TextBox_Leave;
                }
            }
        }

        private void TextBox_Enter(object sender, EventArgs e)
        {
            // Когда TextBox получает фокус, отключаем обработку клавиш формой
            this.KeyPreview = false;
        }

        private void TextBox_Leave(object sender, EventArgs e)
        {
            // Когда TextBox теряет фокус, включаем обработку клавиш формой
            this.KeyPreview = false;
        }

        internal void SetPlugin(BASSGeneratorVstPlugin plugin)
        {
            _plugin = plugin;
        }

        private static Dictionary<string, Dictionary<string, int[]>> InitializeScalesByCategory()
        {
            var result = new Dictionary<string, Dictionary<string, int[]>>();

            var scalePatterns = new Dictionary<string, Dictionary<string, List<int>>>
{
    // Категория: Классические/Западные
    {
        "Классические/Западные", new Dictionary<string, List<int>>
        {
            {"Мажор (Ionian)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Натуральный минор (Aeolian)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Гармонический минор", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Мелодический минор (Asc.)", new List<int> {2, 1, 2, 2, 2, 2, 1}},
            {"Дорийский (Dorian)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Фригийский (Phrygian)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Лидийский (Lydian)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Миксолидийский (Mixolyd.)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Локрийский (Locrian)", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Неаполитанский мажор", new List<int> {1, 2, 2, 2, 2, 2, 1}},
            {"Неаполитанский минор", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Целотонный (Whole Tone)", new List<int> {2, 2, 2, 2, 2, 2}},
            {"Хроматический (12 Half)", new List<int> {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}},
            {"Лидийский доминантный (Lydian Dominant)", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Фригийский доминантный (Phrygian Dominant)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Миксолидийский ♭6", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Локрийский ♮2", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Аугментированный (Augmented)", new List<int> {3, 1, 3, 1, 3, 1}},
            {"Эолийский ♭5 (Aeolian ♭5)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Дорийский ♯4", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Сверхлокрийский (Super Locrian)", new List<int> {1, 2, 1, 2, 2, 2, 2}},
            {"Миксолидийский ♭2", new List<int> {1, 3, 1, 2, 2, 1, 2}},
            {"Дорийский ♭5", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Лидийский ♯2", new List<int> {3, 1, 2, 1, 2, 2, 1}},
            {"Фригийский ♯6", new List<int> {1, 2, 2, 2, 2, 1, 2}},
            {"Миксолидийский ♯11", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Локрийский ♭4", new List<int> {1, 2, 1, 2, 2, 2, 2}},
            {"Гармонический мажор", new List<int> {2, 2, 1, 2, 1, 3, 1}},
            {"Мелодический мажор", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Эолийский ♯7", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Дорийский ♯2", new List<int> {3, 1, 2, 2, 1, 2, 1}},
            {"Лидийский ♭3", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Фригийский ♯3", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Миксолидийский ♭13", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Локрийский ♮6", new List<int> {1, 2, 2, 1, 3, 1, 2}},
            {"Ионийский ♯5", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Эолийский ♭1", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Ионийский ♭6", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Дорийский ♭13", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Фригийский ♭7", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Лидийский ♯5", new List<int> {2, 2, 2, 2, 1, 2, 1}},
            {"Миксолидийский ♯9", new List<int> {3, 1, 1, 2, 2, 1, 2}},
            {"Локрийский ♯7", new List<int> {1, 2, 2, 1, 2, 3, 1}},
            {"Эолийский ♯3", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Дорийский ♭3", new List<int> {2, 1, 1, 3, 2, 1, 2}},
            {"Фригийский ♯2", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Лидийский ♭9", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Миксолидийский ♭5", new List<int> {2, 2, 1, 1, 2, 2, 2}},
            {"Локрийский ♮3", new List<int> {1, 3, 1, 1, 2, 2, 2}},
            {"Ионийский ♭2", new List<int> {1, 3, 1, 2, 2, 2, 1}},
            {"Эолийский ♯6", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Дорийский ♯7", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Фригийский ♭5", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Лидийский ♯11", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♯2", new List<int> {3, 1, 1, 2, 2, 1, 2}},
            {"Локрийский ♭6", new List<int> {1, 2, 2, 1, 2, 1, 3}},
            {"Ионийский ♭3", new List<int> {2, 1, 2, 2, 2, 2, 1}},
            {"Эолийский ♭9", new List<int> {1, 3, 2, 2, 1, 2, 2}},
            {"Дорийский ♭4", new List<int> {2, 1, 1, 3, 2, 1, 2}},
            {"Фригийский ♯9", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Лидийский ♭13", new List<int> {2, 2, 2, 1, 1, 2, 2}},
            {"Миксолидийский ♭7", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Локрийский ♯5", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Ионийский ♯9", new List<int> {3, 1, 1, 2, 2, 2, 1}},
            {"Эолийский ♭2", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Дорийский ♯6", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Фригийский ♭3", new List<int> {1, 2, 1, 3, 1, 2, 2}},
            {"Лидийский ♯3", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Миксолидийский ♯4", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Локрийский ♮9", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Ионийский ♭5", new List<int> {2, 2, 1, 1, 2, 2, 2}},
            {"Эолийский ♯4", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Дорийский ♭6", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Фригийский ♯4", new List<int> {1, 2, 3, 1, 1, 2, 2}},
            {"Лидийский ♭2", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Миксолидийский ♭9", new List<int> {1, 3, 1, 2, 2, 1, 2}},
            {"Локрийский ♭3", new List<int> {1, 2, 1, 2, 2, 2, 2}},
            {"Ионийский ♯6", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Эолийский ♭7", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Дорийский ♯9", new List<int> {3, 1, 1, 2, 2, 1, 2}},
            {"Фригийский ♭6", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Лидийский ♯7", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Миксолидийский ♭4", new List<int> {2, 2, 1, 1, 3, 1, 2}},
            {"Локрийский ♮4", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Ионийский ♭9", new List<int> {1, 3, 1, 2, 2, 2, 1}},
            {"Эолийский ♯5", new List<int> {2, 1, 2, 2, 2, 2, 1}},
            {"Дорийский ♭7", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Фригийский ♯5", new List<int> {1, 2, 2, 2, 2, 1, 2}},
            {"Лидийский ♭4", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Миксолидийский ♯6", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Локрийский ♭9", new List<int> {1, 3, 1, 1, 2, 2, 2}},
            {"Ионийский ♯2", new List<int> {3, 1, 1, 2, 2, 2, 1}},
            {"Эолийский ♭3", new List<int> {2, 1, 1, 3, 1, 2, 2}},
            {"Дорийский ♯5", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Фригийский ♭9", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Лидийский ♯6", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♭3", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Локрийский ♮7", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Ионийский ♭7", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Эолийский ♯9", new List<int> {3, 1, 2, 2, 1, 2, 2}},
            {"Дорийский ♭2", new List<int> {1, 3, 1, 2, 2, 1, 2}},
            {"Фригийский ♯7", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Лидийский ♭5", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Миксолидийский ♯5", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Локрийский ♭2", new List<int> {1, 1, 3, 1, 2, 2, 2}},
            {"Ионийский ♯3", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Эолийский ♭6", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Ионийский ♭13", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Дорийский ♯13", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Фригийский ♭13", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Лидийский ♯13", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♭11", new List<int> {2, 2, 1, 1, 3, 1, 2}},
            {"Локрийский ♯11", new List<int> {1, 2, 3, 1, 1, 2, 2}},
            {"Эолийский ♭4", new List<int> {2, 1, 1, 3, 1, 2, 2}},
            {"Дорийский ♭11", new List<int> {2, 1, 1, 3, 2, 1, 2}},
            {"Фригийский ♯11", new List<int> {1, 2, 3, 1, 1, 2, 2}},
            {"Лидийский ♭11", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Миксолидийский ♯13", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Локрийский ♭5", new List<int> {1, 2, 1, 2, 2, 2, 2}},
            {"Ионийский ♯11", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Эолийский ♯11", new List<int> {2, 1, 3, 1, 1, 2, 2}},
            {"Дорийский ♭9", new List<int> {1, 3, 1, 2, 2, 1, 2}},
            {"Фригийский ♭4", new List<int> {1, 2, 1, 3, 1, 2, 2}},
            {"Лидийский ♯9", new List<int> {3, 1, 2, 1, 2, 2, 1}},
            {"Локрийский ♮5", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Ионийский ♭4", new List<int> {2, 2, 1, 1, 3, 2, 1}},
            {"Эолийский ♭13", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Дорийский ♯3", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Фригийский ♯13", new List<int> {1, 2, 2, 2, 2, 1, 2}},
            {"Лидийский ♭7", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♯7", new List<int> {2, 2, 1, 2, 1, 3, 1}},
            {"Локрийский ♭11", new List<int> {1, 2, 1, 2, 2, 2, 2}},
            {"Ионийский ♯13", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Эолийский ♯2", new List<int> {3, 1, 2, 2, 1, 2, 2}},
            {"Дорийский ♭10", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Фригийский ♭10", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Лидийский ♯10", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Миксолидийский ♭10", new List<int> {2, 2, 1, 1, 2, 2, 2}},
            {"Локрийский ♮10", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Ионийский ♭10", new List<int> {2, 2, 1, 1, 2, 2, 2}},
            {"Эолийский ♯10", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Дорийский ♭8", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Фригийский ♯8", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Лидийский ♭8", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♯8", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Локрийский ♮8", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Ионийский ♭8", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Эолийский ♯8", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Дорийский ♭12", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Фригийский ♯12", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Лидийский ♭12", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♯12", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Локрийский ♮12", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Ионийский ♭12", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Эолийский ♯12", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Дорийский ♭14", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Фригийский ♯14", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Лидийский ♭14", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♯14", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Локрийский ♮14", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Ионийский ♭14", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Эолийский ♯14", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Дорийский ♭15", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Фригийский ♯15", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Лидийский ♭15", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♯15", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Локрийский ♮15", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Ионийский ♭15", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Эолийский ♯15", new List<int> {2, 1, 2, 2, 1, 3, 1}}
        }
    },
    // Категория: Джазовые
    {
        "Джазовые", new Dictionary<string, List<int>>
        {
            {"Мажорный бибоп", new List<int> {2, 2, 1, 2, 2, 1, 1, 2}},
            {"Минорный бибоп", new List<int> {2, 1, 2, 2, 1, 1, 2, 2}},
            {"Доминиантный бибоп", new List<int> {2, 2, 1, 2, 1, 1, 2, 2}},
            {"Джаз-фанк (Jazz Funk)", new List<int> {2, 2, 1, 2, 1, 1, 2}},
            {"Афро-джаз (Afro-Jazz)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Джазовая целотонная (Jazz Whole Tone)", new List<int> {2, 2, 2, 2, 1, 3}},
            {"Лидийский ♭7 (Lydian ♭7)", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♭9", new List<int> {1, 3, 1, 2, 2, 1, 2}},
            {"Дорийский ♭2", new List<int> {1, 2, 2, 2, 2, 1, 2}},
            {"Хроматический бибоп (Chromatic Bebop)", new List<int> {2, 1, 1, 2, 2, 1, 1, 2}},
            {"Фригийский ♭4", new List<int> {1, 2, 1, 3, 1, 2, 2}},
            {"Лидийский увеличенный (Lydian Augmented)", new List<int> {2, 2, 2, 2, 1, 2, 1}},
            {"Полутон-целотон (Half-Whole)", new List<int> {1, 2, 1, 2, 1, 2, 1, 2}},
            {"Целотон-полутон (Whole-Half)", new List<int> {2, 1, 2, 1, 2, 1, 2, 1}},
            {"Дорийский ♭9", new List<int> {1, 3, 1, 2, 2, 1, 2}},
            {"Лидийский ♯9", new List<int> {3, 1, 2, 1, 2, 2, 1}},
            {"Миксолидийский ♯5", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Фригийский ♯7", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Локрийский ♭13", new List<int> {1, 2, 2, 1, 2, 1, 3}},
            {"Бибоп мажор ♭6", new List<int> {2, 2, 1, 2, 1, 1, 2, 2}},
            {"Бибоп минор ♯4", new List<int> {2, 1, 3, 1, 1, 1, 2, 2}},
            {"Дорийский ♯11", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Лидийский ♭6", new List<int> {2, 2, 2, 1, 1, 2, 2}},
            {"Миксолидийский ♭3", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Фригийский ♭2", new List<int> {1, 1, 3, 2, 1, 2, 2}},
            {"Локрийский ♯3", new List<int> {1, 3, 1, 1, 2, 2, 2}},
            {"Джазовый симметричный", new List<int> {1, 3, 1, 3, 1, 3}},
            {"Целотонный ♭5", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Бибоп доминант ♯9", new List<int> {3, 1, 1, 2, 1, 1, 2, 2}},
            {"Дорийский ♯5", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Лидийский ♯2", new List<int> {3, 1, 2, 1, 2, 2, 1}},
            {"Миксолидийский ♭13", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Фригийский ♯6", new List<int> {1, 2, 2, 2, 2, 1, 2}},
            {"Локрийский ♮2", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Бибоп мажор ♯5", new List<int> {2, 2, 2, 1, 1, 1, 2, 2}},
            {"Бибоп минор ♭9", new List<int> {1, 3, 1, 2, 1, 1, 2, 2}},
            {"Дорийский ♭4", new List<int> {2, 1, 1, 3, 2, 1, 2}},
            {"Лидийский ♭3", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Миксолидийский ♯11", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Фригийский ♭5", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Локрийский ♯4", new List<int> {1, 2, 3, 1, 1, 2, 2}},
            {"Джазовый ♭6", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Целотонный ♯5", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Бибоп доминант ♭13", new List<int> {2, 2, 1, 2, 1, 1, 2, 2}},
            {"Дорийский ♭7", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Лидийский ♯6", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♭2", new List<int> {1, 3, 1, 2, 2, 1, 2}},
            {"Фригийский ♯9", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Локрийский ♮6", new List<int> {1, 2, 2, 1, 3, 1, 2}},
            {"Бибоп мажор ♭9", new List<int> {1, 3, 1, 2, 2, 1, 1, 2}},
            {"Бибоп минор ♯7", new List<int> {2, 1, 2, 2, 1, 1, 3, 1}},
            {"Дорийский ♯3", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Лидийский ♭4", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Миксолидийский ♯4", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Фригийский ♭3", new List<int> {1, 2, 1, 3, 1, 2, 2}},
            {"Локрийский ♯5", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Джазовый ♭2", new List<int> {1, 3, 1, 2, 2, 1, 2}},
            {"Целотонный ♭3", new List<int> {2, 1, 2, 2, 2, 3}},
            {"Бибоп доминант ♯5", new List<int> {2, 2, 2, 1, 1, 1, 2, 2}},
            {"Дорийский ♭6", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Лидийский ♯3", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Миксолидийский ♭7", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Фригийский ♯2", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Локрийский ♮9", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Бибоп мажор ♯9", new List<int> {3, 1, 1, 2, 2, 1, 1, 2}},
            {"Бибоп минор ♭13", new List<int> {2, 1, 2, 2, 1, 1, 2, 2}},
            {"Дорийский ♯6", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Лидийский ♭9", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Миксолидийский ♯6", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Фригийский ♭6", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Локрийский ♮4", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Джазовый ♭3", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Целотонный ♯2", new List<int> {3, 1, 2, 2, 2, 2}},
            {"Бибоп доминант ♭9", new List<int> {1, 3, 1, 2, 1, 1, 2, 2}},
            {"Дорийский ♭3", new List<int> {2, 1, 1, 3, 2, 1, 2}},
            {"Лидийский ♯4", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♭4", new List<int> {2, 2, 1, 1, 3, 1, 2}},
            {"Фригийский ♯3", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Локрийский ♭7", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Джазовый ♯5", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Целотонный ♭6", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Бибоп мажор ♭2", new List<int> {1, 3, 1, 2, 2, 1, 1, 2}},
            {"Бибоп минор ♯6", new List<int> {2, 1, 2, 2, 2, 1, 1, 2}},
            {"Дорийский ♯9", new List<int> {3, 1, 1, 2, 2, 1, 2}},
            {"Лидийский ♭2", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Миксолидийский ♯9", new List<int> {3, 1, 1, 2, 2, 1, 2}},
            {"Фригийский ♭9", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Локрийский ♮5", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Джазовый ♭9", new List<int> {1, 3, 1, 2, 2, 1, 2}},
            {"Целотонный ♯3", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Бибоп доминант ♯2", new List<int> {3, 1, 1, 2, 1, 1, 2, 2}},
            {"Дорийский ♭5", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Лидийский ♯7", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Фригийский ♯4", new List<int> {1, 2, 3, 1, 1, 2, 2}},
            {"Локрийский ♭2", new List<int> {1, 1, 3, 1, 2, 2, 2}},
            {"Джазовый ♯2", new List<int> {3, 1, 1, 2, 2, 1, 2}},
            {"Целотонный ♭7", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Джазовый ♭13", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Бибоп мажор ♭13", new List<int> {2, 2, 1, 2, 1, 1, 2, 2}},
            {"Бибоп минор ♯9", new List<int> {3, 1, 1, 2, 1, 1, 2, 2}},
            {"Дорийский ♭11", new List<int> {2, 1, 1, 3, 2, 1, 2}},
            {"Лидийский ♯11", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♭11", new List<int> {2, 2, 1, 1, 3, 1, 2}},
            {"Фригийский ♯11", new List<int> {1, 2, 3, 1, 1, 2, 2}},
            {"Локрийский ♭4", new List<int> {1, 2, 1, 2, 2, 2, 2}},
            {"Джазовый ♯6", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Целотонный ♯9", new List<int> {3, 1, 2, 2, 2, 2}},
            {"Бибоп доминант ♭6", new List<int> {2, 2, 1, 2, 1, 1, 2, 2}},
            {"Дорийский ♯13", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Лидийский ♭13", new List<int> {2, 2, 2, 1, 1, 2, 2}},
            {"Миксолидийский ♯13", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Фригийский ♭13", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Локрийский ♯6", new List<int> {1, 2, 2, 1, 3, 1, 2}},
            {"Джазовый ♭4", new List<int> {2, 2, 1, 1, 3, 2, 1}},
            {"Целотонный ♭2", new List<int> {1, 3, 2, 2, 2, 2}},
            {"Бибоп мажор ♯11", new List<int> {2, 2, 2, 1, 1, 1, 2, 2}},
            {"Бибоп минор ♭2", new List<int> {1, 3, 1, 2, 1, 1, 2, 2}},
            {"Дорийский ♭8", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Лидийский ♯8", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♭8", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Фригийский ♯8", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Локрийский ♮8", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Джазовый ♯9", new List<int> {3, 1, 1, 2, 2, 1, 2}},
            {"Целотонный ♭13", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Бибоп доминант ♯11", new List<int> {2, 2, 2, 1, 1, 1, 2, 2}},
            {"Дорийский ♯4", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Лидийский ♭5", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Миксолидийский ♯2", new List<int> {3, 1, 1, 2, 2, 1, 2}},
            {"Фригийский ♭7", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Локрийский ♯7", new List<int> {1, 2, 2, 1, 2, 3, 1}},
            {"Джазовый ♭5", new List<int> {2, 2, 1, 1, 2, 2, 2}},
            {"Целотонный ♯6", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Бибоп мажор ♭3", new List<int> {2, 1, 2, 2, 2, 1, 1, 2}},
            {"Бибоп минор ♯3", new List<int> {2, 2, 1, 2, 1, 1, 2, 2}},
            {"Дорийский ♭12", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Лидийский ♯12", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♭12", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Фригийский ♯12", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Локрийский ♮12", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Джазовый ♯11", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Целотонный ♭9", new List<int> {1, 3, 2, 2, 2, 2}},
            {"Бибоп доминант ♭2", new List<int> {1, 3, 1, 2, 1, 1, 2, 2}},
            {"Дорийский ♯10", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Лидийский ♭10", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Миксолидийский ♯10", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Фригийский ♭10", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Локрийский ♮10", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Джазовый ♭11", new List<int> {2, 2, 1, 1, 3, 1, 2}},
            {"Целотонный ♯11", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Бибоп мажор ♭4", new List<int> {2, 2, 1, 1, 2, 1, 2, 2}},
            {"Бибоп минор ♯5", new List<int> {2, 1, 2, 2, 2, 1, 1, 2}},
            {"Дорийский ♭14", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Лидийский ♯14", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Миксолидийский ♭14", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Фригийский ♯14", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Локрийский ♮14", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Джазовый ♭7", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Целотонный ♯13", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Бибоп доминант ♭3", new List<int> {2, 1, 2, 2, 1, 1, 2, 2}}
        }
    },
    // Категория: Пентатоники/Блюз
    {
        "Пентатоники/Блюз", new Dictionary<string, List<int>>
        {
            {"Мажорная пентатоника", new List<int> {2, 2, 3, 2, 3}},
            {"Минорная пентатоника", new List<int> {3, 2, 2, 3, 2}},
            {"Блюзовая (Blues)", new List<int> {3, 2, 1, 1, 3, 2}},
            {"Египетская (Egyptian)", new List<int> {2, 1, 2, 2, 2, 2, 3}},
            {"Японская (Hirajoshi)", new List<int> {2, 1, 4, 1, 4}},
            {"Японская (Iwato)", new List<int> {1, 4, 1, 4, 2}},
            {"Китайская (Mongolian)", new List<int> {2, 2, 3, 2, 3}},
            {"Вьетнамская (Vietnamese)", new List<int> {2, 3, 2, 2, 3}},
            {"Тибетская (Tibetan)", new List<int> {2, 2, 3, 2, 3}},
            {"Малайская (Pelog)", new List<int> {1, 2, 4, 1, 4}},
            {"Индийская (Malkauns)", new List<int> {3, 2, 2, 3, 2}},
            {"Индийская (Bhoopali)", new List<int> {2, 2, 1, 2, 3}},
            {"Индийская (Shivranjani)", new List<int> {2, 1, 2, 3, 4}},
            {"Японская (Kumoi)", new List<int> {2, 1, 4, 2, 3}},
            {"Индийская (Hamsadhwani)", new List<int> {2, 2, 2, 3, 3}},
            {"Блюзовая мажорная (Major Blues)", new List<int> {2, 1, 1, 2, 3, 3}},
            {"Пентатоника доминантная (Dominant Pentatonic)", new List<int> {2, 2, 3, 2, 3}},
            {"Кельтская пентатоника (Celtic Pentatonic)", new List<int> {2, 3, 2, 3, 2}},
            {"Балийская (Balinese)", new List<int> {1, 2, 4, 1, 4}},
            {"Индийская (Khamaj)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Японская (Nohkan)", new List<int> {2, 3, 2, 1, 4}},
            {"Африканская (Zezuru)", new List<int> {3, 2, 2, 2, 3}},
            {"Индийская (Mand)", new List<int> {2, 2, 1, 2, 3}},
            {"Японская (Ritsu)", new List<int> {2, 2, 3, 1, 4}},
            {"Китайская (Yu)", new List<int> {2, 3, 2, 2, 3}},
            {"Тайская (Sawasdee)", new List<int> {2, 1, 3, 2, 4}},
            {"Африканская (Nguni)", new List<int> {3, 2, 1, 3, 3}},
            {"Индийская (Basant)", new List<int> {2, 2, 2, 1, 3}},
            {"Японская (Miyako)", new List<int> {1, 4, 1, 3, 3}},
            {"Кельтская (Breton)", new List<int> {2, 1, 3, 3, 3}},
            {"Блюзовая ♯5", new List<int> {3, 2, 2, 1, 3, 1}},
            {"Пентатоника ♭9", new List<int> {1, 3, 2, 3, 3}},
            {"Индийская (Bilaval)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Японская (Yo)", new List<int> {2, 2, 3, 2, 3}},
            {"Китайская (Pi)", new List<int> {3, 2, 2, 2, 3}},
            {"Тайская (Phaung)", new List<int> {2, 1, 3, 2, 4}},
            {"Африканская (Baka)", new List<int> {2, 2, 2, 3, 3}},
            {"Индийская (Megh)", new List<int> {2, 1, 2, 3, 4}},
            {"Японская (In)", new List<int> {1, 4, 1, 4, 2}},
            {"Кельтская (Galician)", new List<int> {2, 1, 3, 2, 4}},
            {"Блюзовая ♭13", new List<int> {3, 2, 1, 1, 2, 2, 2}},
            {"Пентатоника ♯2", new List<int> {3, 1, 2, 3, 3}},
            {"Индийская (Sarang)", new List<int> {2, 2, 1, 2, 3}},
            {"Японская (Shinobue)", new List<int> {2, 1, 4, 1, 4}},
            {"Китайская (Qing)", new List<int> {2, 3, 2, 1, 4}},
            {"Тайская (Lanna)", new List<int> {2, 2, 2, 1, 3}},
            {"Африканская (Shona)", new List<int> {3, 2, 2, 1, 4}},
            {"Индийская (Malhar)", new List<int> {2, 1, 2, 2, 3}},
            {"Японская (Koto)", new List<int> {1, 4, 2, 1, 4}},
            {"Кельтская (Welsh)", new List<int> {2, 1, 2, 2, 3}},
            {"Блюзовая ♯9", new List<int> {3, 1, 1, 1, 3, 2}},
            {"Пентатоника ♭3", new List<int> {2, 1, 3, 3, 3}},
            {"Индийская (Gaud)", new List<int> {2, 2, 2, 1, 3}},
            {"Японская (Shakuhachi)", new List<int> {2, 3, 1, 4, 2}},
            {"Китайская (Xun)", new List<int> {2, 2, 3, 2, 3}},
            {"Тайская (Isan)", new List<int> {2, 1, 3, 2, 4}},
            {"Африканская (Tswana)", new List<int> {3, 2, 1, 3, 3}},
            {"Индийская (Tilang)", new List<int> {2, 2, 1, 2, 3}},
            {"Японская (Hichiriki)", new List<int> {1, 4, 1, 3, 3}},
            {"Кельтская (Cornish)", new List<int> {2, 1, 3, 2, 4}},
            {"Пентатоника ♯5", new List<int> {2, 2, 2, 3, 2}},
            {"Индийская (Ahir)", new List<int> {2, 1, 3, 2, 3}},
            {"Японская (Gagaku)", new List<int> {2, 2, 3, 1, 4}},
            {"Китайская (Zheng)", new List<int> {2, 3, 2, 2, 3}},
            {"Тайская (Morlam)", new List<int> {2, 1, 3, 2, 4}},
            {"Африканская (Xhosa)", new List<int> {3, 2, 1, 3, 3}},
            {"Индийская (Sohini)", new List<int> {2, 2, 2, 1, 3}},
            {"Японская (Ryukyu)", new List<int> {1, 4, 1, 3, 3}},
            {"Кельтская (Manx)", new List<int> {2, 1, 3, 2, 4}},
            {"Блюзовая ♯2", new List<int> {3, 1, 1, 1, 3, 2}},
            {"Пентатоника ♭6", new List<int> {2, 2, 2, 1, 3}},
            {"Индийская (Vachaspati)", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Японская (Sanshin)", new List<int> {2, 1, 4, 1, 4}},
            {"Китайская (Pipa)", new List<int> {2, 3, 2, 1, 4}},
            {"Тайская (Khene)", new List<int> {2, 2, 2, 1, 3}},
            {"Африканская (Venda)", new List<int> {3, 2, 2, 1, 4}},
            {"Индийская (Shyam)", new List<int> {2, 1, 2, 2, 3}},
            {"Японская (Taiko)", new List<int> {1, 4, 2, 1, 4}},
            {"Кельтская (Pictish)", new List<int> {2, 1, 2, 2, 3}},
            {"Блюзовая ♭3", new List<int> {2, 1, 2, 1, 3, 2}},
            {"Пентатоника ♯11", new List<int> {2, 2, 2, 1, 3}},
            {"Индийская (Kapi)", new List<int> {2, 1, 2, 2, 3}},
            {"Японская (Okinawa)", new List<int> {2, 1, 4, 1, 4}},
            {"Китайская (Bianzhong)", new List<int> {2, 3, 2, 2, 3}},
            {"Тайская (Sukothai)", new List<int> {2, 1, 3, 2, 4}},
            {"Африканская (Akan)", new List<int> {3, 2, 1, 3, 3}},
            {"Индийская (Jhinjhoti)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Японская (Komabue)", new List<int> {1, 4, 1, 4, 2}},
            {"Кельтская (Hebridean)", new List<int> {2, 1, 2, 2, 3}},
            {"Блюзовая ♭6", new List<int> {3, 2, 1, 1, 2, 2, 2}},
            {"Пентатоника ♯13", new List<int> {2, 2, 2, 1, 3}},
            {"Индийская (Deshkar)", new List<int> {2, 2, 1, 2, 3}},
            {"Японская (Nokan)", new List<int> {2, 3, 2, 1, 4}},
            {"Китайская (Yueqin)", new List<int> {2, 3, 2, 2, 3}},
            {"Тайская (Ayutthaya)", new List<int> {2, 1, 3, 2, 4}},
            {"Африканская (Yoruba)", new List<int> {3, 2, 1, 3, 3}},
            {"Индийская (Mianki)", new List<int> {2, 1, 2, 2, 3}},
            {"Японская (Tsugaru)", new List<int> {1, 4, 2, 1, 4}},
            {"Кельтская (Shetland)", new List<int> {2, 1, 2, 2, 3}},
            {"Блюзовая ♯11", new List<int> {3, 2, 2, 1, 3, 1}},
            {"Пентатоника ♭2", new List<int> {1, 3, 2, 3, 3}},
            {"Индийская (Patdeep)", new List<int> {2, 1, 2, 2, 3}},
            {"Японская (Biwa)", new List<int> {2, 1, 4, 1, 4}},
            {"Китайская (Sanxian)", new List<int> {2, 3, 2, 1, 4}},
            {"Тайская (Chiang Mai)", new List<int> {2, 2, 2, 1, 3}},
            {"Африканская (Hausa)", new List<int> {3, 2, 2, 1, 4}},
            {"Индийская (Bageshree)", new List<int> {2, 1, 2, 2, 3}},
            {"Японская (Shamisen)", new List<int> {1, 4, 2, 1, 4}},
            {"Кельтская (Orkney)", new List<int> {2, 1, 2, 2, 3}},
            {"Блюзовая ♭2", new List<int> {1, 3, 1, 1, 3, 2}},
            {"Пентатоника ♯9", new List<int> {3, 1, 2, 3, 3}},
            {"Индийская (Maru)", new List<int> {2, 2, 1, 2, 3}},
            {"Японская (Kagura)", new List<int> {2, 1, 4, 1, 4}},
            {"Китайская (Guzheng)", new List<int> {2, 3, 2, 1, 4}},
            {"Тайская (Lan Chang)", new List<int> {2, 2, 2, 1, 3}},
            {"Африканская (Zulu)", new List<int> {3, 2, 2, 1, 4}},
            {"Индийская (Pahadi)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Японская (Noh)", new List<int> {1, 4, 1, 4, 2}},
            {"Кельтская (Faroese)", new List<int> {2, 1, 2, 2, 3}},
            {"Блюзовая ♯13", new List<int> {3, 2, 1, 1, 3, 1}},
            {"Пентатоника ♭13", new List<int> {2, 2, 1, 3, 3}},
            {"Индийская (Sindhu)", new List<int> {2, 1, 2, 2, 3}},
            {"Японская (Ainu)", new List<int> {2, 1, 4, 1, 4}},
            {"Китайская (Hulusi)", new List<int> {2, 3, 2, 1, 4}},
            {"Тайская (Phin)", new List<int> {2, 2, 2, 1, 3}},
            {"Африканская (Swahili)", new List<int> {3, 2, 2, 1, 4}},
            {"Индийская (Kedara)", new List<int> {2, 2, 1, 2, 3}},
            {"Японская (Kabuki)", new List<int> {1, 4, 2, 1, 4}},
            {"Кельтская (Breton Minor)", new List<int> {2, 1, 2, 2, 3}},
            {"Блюзовая ♭11", new List<int> {3, 2, 1, 1, 2, 2, 2}},
            {"Пентатоника ♯6", new List<int> {2, 2, 2, 1, 3}},
        }
    },
    // Категория: Восточные/Экзотические
    {
        "Восточные/Экзотические", new Dictionary<string, List<int>>
        {
            {"Арабский (Bhairav)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Индийская (Todi)", new List<int> {1, 2, 2, 2, 2, 2, 1}},
            {"Персидская (Persian)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Арабская (Hijaz)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Суфийская (Sufi)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Двойной гармонический (Double Harm.)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Венгерский минор (Hungarian Minor)", new List<int> {2, 1, 3, 1, 1, 3, 1}},
            {"Венгерский мажор (Hungarian Major)", new List<int> {3, 1, 2, 1, 2, 1, 2}},
            {"Индийская (Purvi)", new List<int> {1, 3, 1, 2, 2, 2, 1}},
            {"Турецкая (Makam Rast)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Индийская (Bhairavi)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Греческая (Enigmatic)", new List<int> {1, 3, 2, 1, 2, 1, 2}},
            {"Индийская (Marwa)", new List<int> {1, 3, 2, 2, 2, 1, 1}},
            {"Корейская (Pyeongjo)", new List<int> {2, 2, 3, 2, 3}},
            {"Марокканская (Maqam)", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Индонезийская (Slendro)", new List<int> {2, 2, 3, 3, 2}},
            {"Сирийская (Bayati)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Индийская (Yaman)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Индийская (Kafi)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Японская (Ryo)", new List<int> {2, 2, 3, 2, 3}},
            {"Тунисская (Tunisian)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Индийская (Darbari)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Камбоджийская (Khmer)", new List<int> {2, 2, 3, 2, 3}},
            {"Ливанская (Lebanese)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Азербайджанская (Mugham)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Казахская (Kazakh)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Индийская (Bageshri)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Монгольская (Throat)", new List<int> {2, 2, 3, 2, 3}},
            {"Иракская (Iraqi)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Узбекская (Uzbek)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Йеменская (Yemeni)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Туркменская (Turkmen)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Индийская (Asavari)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Турецкая (Hicazkar)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Персидская (Shur)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Индийская (Desh)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Арабская (Nahawand)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Японская (Sakura)", new List<int> {1, 4, 2, 1, 4}},
            {"Индийская (Kalyan)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Тайская (Phimai)", new List<int> {2, 2, 1, 3, 2, 2}},
            {"Китайская (Gong)", new List<int> {2, 2, 3, 2, 3}},
            {"Индийская (Pilu)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Турецкая (Segah)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Индийская (Jaunpuri)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Персидская (Bayat-e Esfahan)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Арабская (Saba)", new List<int> {1, 2, 1, 2, 2, 2, 2}},
            {"Индийская (Bhairav Thaat)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Тайская (Khlui)", new List<int> {2, 2, 2, 1, 3, 2}},
            {"Китайская (Zhi)", new List<int> {2, 2, 1, 2, 3, 2}},
            {"Индийская (Jog)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Узбекская (Navoi)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Монгольская (Urtyn Duu)", new List<int> {2, 2, 3, 2, 3}},
            {"Индийская (Shankarabharanam)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Турецкая (Ussak)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Персидская (Dastgah-e Shur)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Арабская (Rast Panjgah)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Индийская (Kamavardhani)", new List<int> {1, 3, 1, 2, 2, 1, 2}},
            {"Тайская (Ranad)", new List<int> {2, 2, 1, 3, 2, 2}},
            {"Китайская (Shang)", new List<int> {2, 3, 2, 1, 4}},
            {"Индийская (Charukesi)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Узбекская (Buzruk)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Монгольская (Khuumii)", new List<int> {2, 3, 2, 2, 3}},
            {"Турецкая (Kurdilihicazkar)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Индийская (Natabhairavi)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Персидская (Mahur)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Арабская (Ajam)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Индийская (Shuddha Dhanyasi)", new List<int> {2, 1, 2, 3, 4}},
            {"Тайская (Nok)", new List<int> {2, 1, 3, 2, 3, 1}},
            {"Китайская (Jue)", new List<int> {3, 2, 2, 3, 2}},
            {"Индийская (Hemavati)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Узбекская (Rast)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Монгольская (Bayati)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Индийская (Kalyani)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Турецкая (Huzzam)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Арабская (Suznak)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Индийская (Rageshri)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Тайская (Pathet)", new List<int> {2, 2, 1, 3, 2, 2}},
            {"Китайская (Guqin)", new List<int> {2, 3, 2, 1, 4}},
            {"Индийская (Shanmukhapriya)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Узбекская (Shashmaqom)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Монгольская (Morin Khuur)", new List<int> {2, 2, 3, 2, 3}},
            {"Турецкая (Nihavent)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Индийская (Dhenuka)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Персидская (Segah)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Арабская (Hijaz Kar)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Индийская (Kedar)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Тайская (Sralai)", new List<int> {2, 1, 3, 2, 3, 1}},
            {"Китайская (Erhu)", new List<int> {2, 2, 3, 2, 3}},
            {"Индийская (Mayamalavagowla)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Узбекская (Tanbur)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Монгольская (Yatga)", new List<int> {2, 3, 2, 2, 3}},
            {"Турецкая (Sultaniyegah)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Индийская (Gowrimanohari)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Персидская (Chahargah)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Арабская (Bayati Shuri)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Индийская (Bhavapriya)", new List<int> {1, 3, 1, 2, 2, 1, 2}},
            {"Тайская (Pin)", new List<int> {2, 2, 1, 3, 2, 2}},
            {"Китайская (Xiao)", new List<int> {2, 2, 3, 2, 3}},
            {"Индийская (Suryakantam)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Узбекская (Dutar)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Монгольская (Tsuur)", new List<int> {2, 3, 2, 2, 3}},
            {"Турецкая (Bestenigar)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Индийская (Dharmavati)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Персидская (Rast-Panjgah)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Арабская (Kurd)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Индийская (Chakravakam)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Тайская (Chakhe)", new List<int> {2, 2, 1, 3, 2, 2}},
            {"Китайская (Dizi)", new List<int> {2, 3, 2, 1, 4}},
            {"Индийская (Vagadheeswari)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Узбекская (Rubab)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Монгольская (Shudarga)", new List<int> {2, 2, 3, 2, 3}},
            {"Турецкая (Huseyni)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Индийская (Hanumatodi)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Персидская (Homayun)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Арабская (Sikah)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Индийская (Gamanashrama)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Тайская (Saw)", new List<int> {2, 2, 1, 3, 2, 2}},
            {"Китайская (Sheng)", new List<int> {2, 3, 2, 1, 4}},
            {"Индийская (Kokilapriya)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Узбекская (Sato)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Монгольская (Ikh Khuur)", new List<int> {2, 2, 3, 2, 3}},
            {"Турецкая (Saba Zemzeme)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Индийская (Ramapriya)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Персидская (Dasht-e Arzoo)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Арабская (Hijaz Kar Kurd)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Индийская (Senavati)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Тайская (Khong)", new List<int> {2, 2, 1, 3, 2, 2}},
            {"Китайская (Yangqin)", new List<int> {2, 3, 2, 1, 4}},
            {"Индийская (Harikambhoji)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Узбекская (Ghidjak)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Монгольская (Limbe)", new List<int> {2, 2, 3, 2, 3}},
            {"Турецкая (Acem)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Индийская (Kharaharapriya)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Персидская (Bayat-e Turk)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Арабская (Nawa Athar)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Индийская (Ganamurti)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Тайская (Ranat)", new List<int> {2, 2, 1, 3, 2, 2}},
            {"Китайская (Banhu)", new List<int> {2, 3, 2, 1, 4}},
            {"Индийская (Navaneetam)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Узбекская (Chang)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Монгольская (Tovshuur)", new List<int> {2, 2, 3, 2, 3}},
            {"Турецкая (Suzidil)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Индийская (Pavani)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Персидская (Bayat-e Zand)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Арабская (Shahnaz)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Индийская (Rupavati)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Тайская (Pi)", new List<int> {2, 2, 1, 3, 2, 2}},
            {"Китайская (Gaohu)", new List<int> {2, 3, 2, 1, 4}},
            {"Индийская (Gavambodhi)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Узбекская (Nay)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Монгольская (Shanz)", new List<int> {2, 2, 3, 2, 3}},
            {"Турецкая (Beyati)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Индийская (Bhairav Bahar)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Персидская (Afshari)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Арабская (Rahat al-Arwah)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Индийская (Kalyani Yaman)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Тайская (Thon)", new List<int> {2, 2, 1, 3, 2, 2}},
            {"Китайская (Liuqin)", new List<int> {2, 3, 2, 1, 4}},
            {"Индийская (Sarasangi)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Узбекская (Karnay)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Монгольская (Hoomei)", new List<int> {2, 2, 3, 2, 3}},
            {"Турецкая (Mahur)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Индийская (Vasantha)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Персидская (Bayat-e Kord)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Арабская (Hijaz Nawah)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Индийская (Jyoti)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Тайская (Khong Wong)", new List<int> {2, 2, 1, 3, 2, 2}},
            {"Китайская (Ruan)", new List<int> {2, 3, 2, 1, 4}},
            {"Индийская (Latangi)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Узбекская (Doira)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Монгольская (Choor)", new List<int> {2, 2, 3, 2, 3}},
            // Добавленные еврейские лады
            {"Еврейский (Ahava Rabbah)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Еврейский (Magen Avot)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Еврейский (Mi Sheberach)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Еврейский (Adonai Malach)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Еврейский (Klezmer Phrygian)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Еврейский (Yishtabach)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Еврейский (Freygish)", new List<int> {1, 3, 1, 2, 1, 2, 2}}, // Альтернативное название для Ahava Rabbah
            {"Еврейский (Misheberach Minor)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Еврейский (Klezmer Major)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Еврейский (Shabbat Mode)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Индийская (Shri)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Индийская (Hindol)", new List<int> {2, 2, 2, 3, 3}},
            {"Индийская (Tilak Kamod)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Индийская (Chandrakauns)", new List<int> {2, 1, 3, 2, 4}},
            {"Индийская (Shuddha Sarali)", new List<int> {2, 1, 2, 2, 2, 2, 1}},
            {"Турецкая (Çargah)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Турецкая (Buselik)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Турецкая (Isfahanek)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Турецкая (Nişaburek)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Турецкая (Hüzzam Segah)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Персидская (Nava)", new List<int> {2, 1, 2, 2, 1, 2, 2}}
        }
    },
    // Категория: Арабские макаматы
    {
        "Арабские макаматы", new Dictionary<string, List<int>>
        {
            {"Раст (راست - Rast)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Баяти (بياتي - Bayati)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Сика (سيكاه - Sikah)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Хиджаз (حجاز - Hijaz)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Хиджаз Кар (حجاز كار - Hijaz Kar)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Нахаванд (نهاوند - Nahawand)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Курд (كرد - Kurd)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Адшам (عجم - Ajam)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Саба (صبا - Saba)", new List<int> {1, 2, 1, 2, 2, 2, 2}},
            {"Сузнак (سوزناك - Suznak)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Хуззам (هزام - Huzzam)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Бастанигар (بستنكار - Bastanigar)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Шахназ (شهناز - Shahnaz)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Рахат аль-Арвах (راحة الأرواح - Rahat al-Arwah)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Нихавент (نهاوند - Nihavent)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Хусейни (حسيني - Husayni)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Баяти Шури (بياتي شوري - Bayati Shuri)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Раст Панжгах (راست پنجگاه - Rast Panjgah)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Курдилихиджазкар (كرديلهجازكار - Kurdilihijazkar)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Сабаземземе (صبا زمزمة - Saba Zemzeme)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Хиджаз Навва (حجاز نوا - Hijaz Nawah)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Адшам Ашир (عجم عاشير - Ajam Ashir)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Суздиль (سوزديل - Suzidil)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Султанийегях (سلطاني يگاه - Sultaniyegah)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Нахаванд Курд (نهاوند كرد - Nahawand Kurd)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Хиджаз Кар Курд (حجاز كار كرد - Hijaz Kar Kurd)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Сика Балди (سيكاه بلدي - Sikah Baladi)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Рамаль (رمل - Ramal)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Шадд Арабан (شد عربان - Shadd Araban)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Зангула (زنكولة - Zangula)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Махур (ماهور - Mahur)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Бузург (بزرگ - Buzurg)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Ирак (عراق - Iraq)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Исфахан (أصفهان - Isfahan)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Джигархан (جكارخان - Jigarkhan)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Харидж Хиджаз (خارج حجاز - Kharaj Hijaz)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Фарахфеза (فرحفزا - Farahfaza)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Шуштар (شوشتر - Shushtar)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Накш (نقش - Naqsh)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Баяти Курд (بياتي كرد - Bayati Kurd)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Хиджаз Ашир (حجاز عاشير - Hijaz Ashir)", new List<int> {1, 3, 1, 2, 1, 3, 1}},
            {"Сузнак Курд (سوزناك كرد - Suznak Kurd)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Раст Курд (راست كرد - Rast Kurd)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Сика Хузам (سيكاه هزام - Sikah Huzam)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Нахаванд Хиджаз (نهاوند حجاز - Nahawand Hijaz)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Курд Хиджаз (كرد حجاز - Kurd Hijaz)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Адшам Мурраса (عجم مرصع - Ajam Murrasa)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Саба Далансин (صبا دلنشين - Saba Dalansin)", new List<int> {1, 2, 1, 2, 2, 2, 2}},
            {"Хуззам Курд (هزام كرد - Huzzam Kurd)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Бастанигар Курд (بستنكار كرد - Bastanigar Kurd)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Шахназ Курд (شهناز كرد - Shahnaz Kurd)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Рахат аль-Арвах Курд (راحة الأرواح كرد - Rahat al-Arwah Kurd)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Нихавент Хиджаз (نهاوند حجاز - Nihavent Hijaz)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Хусейни Курд (حسيني كرد - Husayni Kurd)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Баяти Шури Курд (بياتي شوري كرد - Bayati Shuri Kurd)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Раст Панжгах Курд (راست پنجگاه كرد - Rast Panjgah Kurd)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Курдилихиджазкар Курд (كرديلهجازكار كرد - Kurdilihijazkar Kurd)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Сабаземземе Курд (صبا زمزمة كرد - Saba Zemzeme Kurd)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Хиджаз Навва Курд (حجاز نوا كرد - Hijaz Nawah Kurd)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Адшам Ашир Курд (عجم عاشير كرد - Ajam Ashir Kurd)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Суздиль Курд (سوزديل كرد - Suzidil Kurd)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Султанийегях Курд (سلطاني يگاه كرد - Sultaniyegah Kurd)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Нахаванд Хиджаз Кар (نهاوند حجاز كار - Nahawand Hijaz Kar)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Хиджаз Кар Курд Ашир (حجاز كار كرد عاشير - Hijaz Kar Kurd Ashir)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Сика Балди Курд (سيكاه بلدي كرد - Sikah Baladi Kurd)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Рамаль Курд (رمل كرد - Ramal Kurd)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Шадд Арабан Курд (شد عربان كرد - Shadd Araban Kurd)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Зангула Курд (زنكولة كرد - Zangula Kurd)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Махур Курд (ماهور كرد - Mahur Kurd)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Бузург Курд (بزرگ كرد - Buzurg Kurd)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Ирак Курд (عراق كرد - Iraq Kurd)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Исфахан Курд (أصفهان كرد - Isfahan Kurd)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Джигархан Курд (جكارخان كرد - Jigarkhan Kurd)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Харидж Хиджаз Курд (خارج حجاز كرد - Kharaj Hijaz Kurd)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Фарахфеза Курд (فرحفزا كرد - Farahfaza Kurd)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Шуштар Курд (شوشتر كرد - Shushtar Kurd)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Накш Курд (نقش كرد - Naqsh Kurd)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Баяти Ашир (بياتي عاشير - Bayati Ashir)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Хиджаз Ашир Курд (حجاز عاشير كرد - Hijaz Ashir Kurd)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Сузнак Ашир (سوزناك عاشير - Suznak Ashir)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Раст Ашир (راست عاشير - Rast Ashir)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Сика Хузам Ашир (سيكاه هزام عاشير - Sikah Huzam Ashir)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Нахаванд Ашир (نهاوند عاشير - Nahawand Ashir)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Курд Ашир (كرد عاشير - Kurd Ashir)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Адшам Мурраса Ашир (عجم مرصع عاشير - Ajam Murrasa Ashir)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Саба Далансин Ашир (صبا دلنشين عاشير - Saba Dalansin Ashir)", new List<int> {1, 2, 1, 2, 2, 2, 2}},
            {"Хуззам Ашир (هزام عاشير - Huzzam Ashir)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Бастанигар Ашир (بستنكار عاشير - Bastanigar Ashir)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Шахназ Ашир (شهناز عاشير - Shahnaz Ashir)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Рахат аль-Арвах Ашир (راحة الأرواح عاشير - Rahat al-Arwah Ashir)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Нихавент Ашир (نهاوند عاشير - Nihavent Ashir)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Хусейни Ашир (حسيني عاشير - Husayni Ashir)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Баяти Шури Ашир (بياتي شوري عاشير - Bayati Shuri Ashir)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Раст Панжгах Ашир (راست پنجگاه عاشير - Rast Panjgah Ashir)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Курдилихиджазкар Ашир (كرديلهجازكار عاشير - Kurdilihijazkar Ashir)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Сабаземземе Ашир (صبا زمزمة عاشير - Saba Zemzeme Ashir)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Хиджаз Навва Ашир (حجاز نوا عاشير - Hijaz Nawah Ashir)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Адшам Ашир Ашир (عجم عاشير عاشير - Ajam Ashir Ashir)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Суздиль Ашир (سوزديل عاشير - Suzidil Ashir)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Султанийегях Ашир (سلطاني يگاه عاشير - Sultaniyegah Ashir)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Нахаванд Хиджаз Ашир (نهاوند حجاز عاشير - Nahawand Hijaz Ashir)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Хиджаз Кар Ашир (حجاز كار عاشير - Hijaz Kar Ashir)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Сика Балди Ашир (سيكاه بلدي عاشير - Sikah Baladi Ashir)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Рамаль Ашир (رمل عاشير - Ramal Ashir)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Шадд Арабан Ашир (شد عربان عاشير - Shadd Araban Ashir)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Зангула Ашир (زنكولة عاشير - Zangula Ashir)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Махур Ашир (ماهور عاشير - Mahur Ashir)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Бузург Ашир (بزرگ عاشير - Buzurg Ashir)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Ирак Ашир (عراق عاشير - Iraq Ashir)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Исфахан Ашир (أصفهان عاشير - Isfahan Ashir)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Джигархан Ашир (جكارخان عاشير - Jigarkhan Ashir)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Харидж Хиджаз Ашир (خارج حجاز عاشير - Kharaj Hijaz Ashir)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Фарахфеза Ашир (فرحفزا عاشير - Farahfaza Ashir)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Шуштар Ашир (شوشتر عاشير - Shushtar Ashir)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Накш Ашир (نقش عاشير - Naqsh Ashir)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Баяти Хиджаз (بياتي حجاز - Bayati Hijaz)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Хиджаз Сика (حجاز سيكاه - Hijaz Sikah)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Сузнак Сика (سوزناك سيكاه - Suznak Sikah)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Раст Сика (راست سيكاه - Rast Sikah)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Сика Нахаванд (سيكاه نهاوند - Sikah Nahawand)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Нахаванд Сика (نهاوند سيكاه - Nahawand Sikah)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Курд Сика (كرد سيكاه - Kurd Sikah)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Адшам Сика (عجم سيكاه - Ajam Sikah)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Саба Сика (صبا سيكاه - Saba Sikah)", new List<int> {1, 2, 1, 2, 2, 2, 2}},
            {"Хуззам Сика (هزام سيكاه - Huzzam Sikah)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Бастанигар Сика (بستنكار سيكاه - Bastanigar Sikah)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Шахназ Сика (شهناز سيكاه - Shahnaz Sikah)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Рахат аль-Арвах Сика (راحة الأرواح سيكاه - Rahat al-Arwah Sikah)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Нихавент Сика (نهاوند سيكاه - Nihavent Sikah)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Хусейни Сика (حسيني سيكاه - Husayni Sikah)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Баяти Шури Сика (بياتي شوري سيكاه - Bayati Shuri Sikah)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Раст Панжгах Сика (راست پنجگاه سيكاه - Rast Panjgah Sikah)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Курдилихиджазкар Сика (كرديلهجازكار سيكاه - Kurdilihijazkar Sikah)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Сабаземземе Сика (صبا زمزمة سيكاه - Saba Zemzeme Sikah)", new List<int> {1, 2, 2, 2, 1, 2, 2}},
            {"Хиджаз Навва Сика (حجاز نوا سيكاه - Hijaz Nawah Sikah)", new List<int> {1, 3, 1, 2, 1, 2, 2}}
        }
    },
    // Категория: Европейские/Фольклорные
    {
        "Европейские/Фольклорные", new Dictionary<string, List<int>>
        {
            {"Испанский фригийский (Spanish Phrygian)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Балканская (Balkan)", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Цыганская (Gypsy)", new List<int> {1, 3, 2, 1, 1, 3, 1}},
            {"Кельтская (Celtic)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Фламенко (Flamenco)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Гавайская (Hawaiian)", new List<int> {2, 1, 2, 2, 3, 2}},
            {"Румынская (Romanian Minor)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Ирландская (Irish)", new List<int> {2, 1, 2, 2, 2, 2, 1}},
            {"Северная (Nordic)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Шотландская (Scottish)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Польская (Mazurka)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Русская (Russian Minor)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Испанская (Andalusian)", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Тайская (Thai)", new List<int> {2, 2, 1, 2, 3, 2}},
            {"Чешская (Bohemian)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Литовская (Lithuanian)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Французская (Chanson)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Украинская (Ukrainian)", new List<int> {2, 1, 3, 1, 1, 3, 1}},
            {"Бирманская (Burmese)", new List<int> {2, 2, 2, 3, 3}},
            {"Португальская (Fado)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Армянская (Armenian)", new List<int> {1, 3, 1, 2, 2, 2, 1}},
            {"Грузинская (Georgian)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Непальская (Nepali)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Исландская (Icelandic)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Болгарская (Bulgarian)", new List<int> {1, 2, 3, 1, 2, 2, 1}},
            {"Итальянская (Tarantella)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Белорусская (Belarusian)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Финская (Finnish)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Сербийская (Serbian)", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Эстонская (Estonian)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Норвежская (Norwegian)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Хорватская (Croatian)", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Галисийская (Galician)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Словацкая (Slovak)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Валлийская (Welsh)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Баскская (Basque)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Македонская (Macedonian)", new List<int> {1, 2, 3, 1, 2, 2, 1}},
            {"Латвийская (Latvian)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Саамская (Sami)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Каталонская (Catalan)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Сардинская (Sardinian)", new List<int> {1, 3, 1, 2, 2, 2, 1}},
            {"Албанская (Çifteli)", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Бретонская (Breizh)", new List<int> {2, 1, 2, 2, 2, 2, 1}},
            {"Словенская (Slovenska)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Корсиканская (Corsican)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Швейцарская (Alpine)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Молдавская (Moldovan)", new List<int> {2, 1, 3, 1, 1, 3, 1}},
            {"Фламандская (Flemish)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Лапландская (Lappish)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Сицилийская (Sicilian)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Боснийская (Bosnian)", new List<int> {1, 2, 3, 1, 2, 2, 1}},
            {"Критская (Cretan)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Датская (Danish)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Австрийская (Tyrolean)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Гэльская (Gaelic)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Кипрская (Cypriot)", new List<int> {1, 3, 1, 2, 2, 2, 1}},
            // Новые лады (70)
            {"Греческая (Chromatic Dorian)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Венгерская (Verbunkos)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Румынская (Doina)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Ирландская (Sean-nós)", new List<int> {2, 1, 2, 2, 2, 2, 1}},
            {"Шведская (Polska)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Польская (Oberek)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Русская (Bylina)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Испанская (Malagueña)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Итальянская (Canzone)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Французская (Musette)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Украинская (Duma)", new List<int> {2, 1, 3, 1, 1, 3, 1}},
            {"Болгарская (Rachenitsa)", new List<int> {1, 2, 3, 1, 2, 2, 1}},
            {"Сербская (Kolo)", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Хорватская (Tamburica)", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Галисийская (Muiñeira)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Словацкая (Čardáš)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Валлийская (Hiraeth)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Баскская (Zortziko)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Македонская (Oro)", new List<int> {1, 2, 3, 1, 2, 2, 1}},
            {"Латвийская (Daina)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Саамская (Joik)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Каталонская (Sardana)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Сардинская (Cantu)", new List<int> {1, 3, 1, 2, 2, 2, 1}},
            {"Албанская (Iso-Polyphony)", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Бретонская (Kan Ha Diskan)", new List<int> {2, 1, 2, 2, 2, 2, 1}},
            {"Словенская (Ljudska)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Корсиканская (Paghjella)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Швейцарская (Jodel)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Молдавская (Horo)", new List<int> {2, 1, 3, 1, 1, 3, 1}},
            {"Фламандская (Volkslied)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Лапландская (Reindeer)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Сицилийская (Siciliana)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Боснийская (Sevdalinka)", new List<int> {1, 2, 3, 1, 2, 2, 1}},
            {"Критская (Rizitiko)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Датская (Folkevise)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Австрийская (Ländler)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Гэльская (Puirt à Beul)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Кипрская (Tsiattista)", new List<int> {1, 3, 1, 2, 2, 2, 1}},
            {"Немецкая (Volksmusik)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Шотландская (Pibroch)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Исландская (Rímur)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Эстонская (Regilaul)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Литовская (Sutartinė)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Финская (Kalevala)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Норвежская (Stev)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Белорусская (Kolyada)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Чешская (Lidová)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Португальская (Canto)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Грузинская (Chakrulo)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Армянская (Duduk)", new List<int> {1, 3, 1, 2, 2, 2, 1}},
            {"Балканская (Izvorna)", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Швейцарская (Ranz)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Словенская (Kajkavian)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Корсиканская (Lamentu)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Саамская (Leudd)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Каталонская (Havanera)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Сардинская (Tenore)", new List<int> {1, 3, 1, 2, 2, 2, 1}},
            {"Албанская (Këngë)", new List<int> {1, 3, 2, 1, 2, 2, 1}},
            {"Бретонская (Gwerz)", new List<int> {2, 1, 2, 2, 2, 2, 1}},
            {"Словенская (Ziljska)", new List<int> {2, 1, 3, 1, 2, 1, 2}},
            {"Корсиканская (Voceru)", new List<int> {1, 2, 2, 2, 1, 3, 1}},
            {"Швейцарская (Schwyzer)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Молдавская (Manea)", new List<int> {2, 1, 3, 1, 1, 3, 1}},
            {"Фламандская (Kempisch)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Лапландская (Vuolle)", new List<int> {2, 2, 2, 1, 2, 3}}
        }
    },
    // Категория: Африканские/Латиноамериканские
    {
        "Африканские/Латиноамериканские", new Dictionary<string, List<int>>
        {
            {"Алжирская (Algerian)", new List<int> {2, 1, 3, 1, 1, 2, 2}},
            {"Эфиопская (Ethiopian)", new List<int> {2, 2, 1, 2, 3, 2}},
            {"Африканская (Kora)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Кубинская (Cuban)", new List<int> {2, 2, 1, 2, 1, 3, 1}},
            {"Кенийская (Kenyan)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Африканская (Mbira)", new List<int> {2, 2, 2, 1, 3, 2}},
            {"Бразильская (Samba)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Карибская (Calypso)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Латино (Latin)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Нигерийская (Highlife)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Мексиканская (Mariachi)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Лаосская (Lao)", new List<int> {2, 2, 2, 1, 3, 2}},
            {"Малагасийская (Malagasy)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Венесуэльская (Joropo)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Ганская (Ghanaian)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Колумбийская (Cumbia)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Танго (Tango)", new List<int> {2, 1, 2, 2, 1, 3, 1}},
            {"Филиппинская (Kundiman)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Южноафриканская (Zulu)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Перуанская (Huayno)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Кубинская (Son)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Ямайская (Mento)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Африканская (Soukous)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Суданская (Nubian)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Боливийская (Saya)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Африканская (Pygmy)", new List<int> {2, 2, 2, 3, 3}},
            {"Гватемальская (Marimba)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Малийская (Griot)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Аргентинская (Chacarera)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Угандийская (Acholi)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Чилийская (Cueca)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Сенегальская (Mbalax)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Эквадорская (Sanjuán)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Камерунская (Bikutsi)", new List<int> {2, 2, 2, 1, 3, 2}},
            {"Панамская (Tamborito)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Танзанийская (Taarab)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Доминиканская (Merengue)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Зимбабвийская (Mbira)", new List<int> {2, 2, 2, 1, 3, 2}},
            {"Уругвайская (Candombe)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Гвинейская (Kora)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Коста-Риканская (Punto)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Мозамбикская (Marrabenta)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            // Новые лады (70)
            {"Ганская (Adowa)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Аргентинская (Zamba)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Кенийская (Benga)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Чилийская (Tonada)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Сенегальская (Sabar)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Эквадорская (Pasillo)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Камерунская (Makosa)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Панамская (Mejorana)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Танзанийская (Ngoma)", new List<int> {2, 2, 2, 1, 3, 2}},
            {"Доминиканская (Bachata)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Зимбабвийская (Chimurenga)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Уругвайская (Milonga)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Гвинейская (Balafon)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Коста-Риканская (Calypso Limón)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Мозамбикская (Timbila)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Нигерийская (Juju)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Бразильская (Forró)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Кубинская (Rumba)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Ямайская (Rocksteady)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Перуанская (Marinera)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Малийская (Wassoulou)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Аргентинская (Chamame)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Кенийская (Ohangla)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Чилийская (Mapuche)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Сенегальская (Wolof)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Эквадорская (Albazo)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Камерунская (Assiko)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Панамская (Cumbia Panameña)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Танзанийская (Bajuni)", new List<int> {2, 2, 2, 1, 3, 2}},
            {"Доминиканская (Palo)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Зимбабвийская (Shona Mbira)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Уругвайская (Tango Criollo)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Гвинейская (Mandinka)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Коста-Риканская (Guanacaste)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Мозамбикская (Chopi)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Ганская (Ewe)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Аргентинская (Payada)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Кенийская (Luo)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Чилийская (Rapa Nui)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Сенегальская (Serer)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Эквадорская (Yumbo)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Камерунская (Bamileke)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Панамская (Saloma)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Танзанийская (Zaramo)", new List<int> {2, 2, 2, 1, 3, 2}},
            {"Доминиканская (Gaga)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Зимбабвийская (Ndebele)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Уругвайская (Pericón)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Гвинейская (Susu)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Коста-Риканская (Siquirres)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Мозамбикская (Makua)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Нигерийская (Fuji)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Бразильская (Choro)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Кубинская (Danzón)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Ямайская (Ska)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Перуанская (Festejo)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Малийская (Bambara)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Аргентинская (Carnavalito)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Кенийская (Chakacha)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Чилийская (Cueca Norteña)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Сенегальская (Tassu)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Эквадорская (Bomba)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Камерунская (Ambasse Bey)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Панамская (Punto Panameño)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Танзанийская (Mdundiko)", new List<int> {2, 2, 2, 1, 3, 2}},
            {"Доминиканская (Mangulina)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Зимбабвийская (Jerusarema)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Уругвайская (Cielito)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Гвинейская (Fula)", new List<int> {2, 2, 2, 1, 2, 3}},
            {"Коста-Риканская (Tambito)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Мозамбикская (Tufo)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Африканская (Mande)", new List<int> {2, 2, 1, 2, 2, 3}},
            {"Африканская (Igbo)", new List<int> {2, 2, 2, 1, 3, 2}},
            {"Африканская (Ashanti)", new List<int> {2, 2, 1, 2, 3, 2}},
            {"Африканская (San)", new List<int> {3, 2, 2, 3, 2}},
            {"Африканская (Bakongo)", new List<int> {2, 1, 2, 2, 2, 3}}
        }
    },

    // Категория: Современные/Жанровые
    {
        "Современные/Жанровые", new Dictionary<string, List<int>>
        {
            {"Транс (Trance)", new List<int> {3, 1, 2, 2, 2, 1, 1}},
            {"Пситранс (PsyTrance)", new List<int> {3, 2, 1, 2, 1, 2, 1}},
            {"Синематик (Cinematic)", new List<int> {2, 2, 1, 3, 1, 2, 1}},
            {"Эмбиент (Ambient)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Драм-н-бейс (DnB)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Сайоми (Saiomy)", new List<int> {3, 1, 1, 3, 1, 2, 1}},
            {"Современная (Modern Fusion)", new List<int> {2, 1, 2, 1, 2, 1, 2}},
            {"Экспериментальная (Experimental)", new List<int> {1, 2, 1, 3, 1, 2, 2}},
            {"Техно (Techno)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Космическая (Space)", new List<int> {2, 2, 2, 1, 2, 1, 2}},
            {"Регги (Reggae)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Дабстеп (Dubstep)", new List<int> {3, 1, 2, 1, 2, 2, 1}},
            {"Минимализм (Minimal)", new List<int> {2, 2, 2, 2, 1, 2, 1}},
            {"Фьюжн (Fusion)", new List<int> {2, 1, 2, 1, 2, 2, 1}},
            {"Хип-хоп (Hip-Hop)", new List<int> {3, 2, 2, 1, 2, 2}},
            {"Брейкбит (Breakbeat)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Глитч (Glitch)", new List<int> {1, 2, 1, 2, 2, 1, 3}},
            {"Чиллаут (Chillout)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Нью-эйдж (New Age)", new List<int> {2, 2, 2, 2, 1, 2, 1}},
            {"Рок (Rock)", new List<int> {3, 2, 2, 3, 2}},
            {"Диско (Disco)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Электро (Electro)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Индастриал (Industrial)", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Даунтемпо (Downtempo)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Эпик (Epic)", new List<int> {2, 2, 1, 3, 1, 2, 1}},
            {"Кантри (Country)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Ска (Ska)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Трип-хоп (Trip-Hop)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Гранж (Grunge)", new List<int> {3, 2, 2, 3, 2}},
            {"Дарк-эмбиент (Dark Ambient)", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Симфонический (Symphonic)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Поп (Pop)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Соул (Soul)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Фанк (Funk)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Хаус (House)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Дрилл (Drill)", new List<int> {3, 2, 2, 1, 2, 2}},
            {"Трап (Trap)", new List<int> {3, 2, 2, 3, 2}},
            {"Ретро (Retro)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Этно-фьюжн (Ethno Fusion)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Авангард (Avant-Garde)", new List<int> {1, 2, 1, 3, 1, 2, 2}},
            {"Барокко (Baroque)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Классический рок (Classic Rock)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Прогрессив (Progressive)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Метал (Metal)", new List<int> {3, 2, 2, 3, 2}},
            {"Дрим-поп (Dream Pop)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Лоу-фай (Lo-Fi)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Нойз (Noise)", new List<int> {1, 2, 1, 2, 2, 1, 3}},
            {"Рагга (Ragga)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Госпел (Gospel)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Этно-джаз (Ethno Jazz)", new List<int> {2, 1, 2, 2, 1, 1, 2}},
            {"Синтвейв (Synthwave)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"R&B (R&B)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Блюз-рок (Blues Rock)", new List<int> {3, 2, 1, 1, 3, 2}},
            {"Альтернатива (Alternative)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Панк (Punk)", new List<int> {3, 2, 2, 3, 2}},
            {"Эмбиент-джаз (Ambient Jazz)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Хард-рок (Hard Rock)", new List<int> {3, 2, 2, 3, 2}},
            {"Джангл (Jungle)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Гараж (Garage)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Шугейз (Shoegaze)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Даб (Dub)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Этно-эмбиент (Ethno Ambient)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Техно-эмбиент (Techno Ambient)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Нью-скул (New School)", new List<int> {3, 2, 2, 1, 2, 2}},
            {"Прогрессив-хаус (Progressive House)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Нью-джаз (Nu Jazz)", new List<int> {2, 1, 2, 2, 1, 1, 2}},
            {"Бразильский фонк (Brazilian Phonk)", new List<int> {3, 2, 2, 1, 2, 2}},
            {"Гиперпоп (Hyperpop)", new List<int> {2, 1, 2, 1, 2, 1, 3}},
            {"Вейпорвейв (Vaporwave)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Чиллстеп (Chillstep)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Фьюжн-рок (Fusion Rock)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Техно-поп (Techno Pop)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Этно-рок (Ethno Rock)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Нью-метал (Nu Metal)", new List<int> {3, 2, 2, 3, 2}},
            {"Дарквейв (Darkwave)", new List<int> {1, 2, 2, 1, 2, 2, 2}},
            {"Синти-поп (Synth Pop)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Этно-даб (Ethno Dub)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Техно-фанк (Techno Funk)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Глитч-хоп (Glitch Hop)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Прогрессив-метал (Progressive Metal)", new List<int> {3, 2, 1, 2, 2, 2}},
            {"Чилл-хаус (Chill House)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Этно-транс (Ethno Trance)", new List<int> {3, 1, 2, 2, 1, 2, 1}},
            {"Нью-кантри (New Country)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Дарк-джаз (Dark Jazz)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Фонк (Phonk)", new List<int> {3, 2, 2, 1, 2, 2}},
            {"Этно-поп (Ethno Pop)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Техно-дабстеп (Techno Dubstep)", new List<int> {3, 1, 2, 1, 2, 2, 1}},
            {"Синти-фанк (Synth Funk)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Глитч-рок (Glitch Rock)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Прогрессив-фанк (Progressive Funk)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Дрим-рок (Dream Rock)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Нью-фолк (New Folk)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Этно-драм (Ethno Drum)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Техно-регги (Techno Reggae)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Чилл-фонк (Chill Phonk)", new List<int> {3, 2, 2, 1, 2, 2}},
            // Новые лады (70)
            {"Дарк-хаус (Dark House)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Нью-диско (New Disco)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Этно-техно (Ethno Techno)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Прогрессив-джаз (Progressive Jazz)", new List<int> {2, 1, 2, 2, 1, 1, 2}},
            {"Синти-рок (Synth Rock)", new List<int> {3, 2, 2, 3, 2}},
            {"Глитч-фанк (Glitch Funk)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Чилл-даб (Chill Dub)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Техно-фьюжн (Techno Fusion)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Нью-регги (New Reggae)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Этно-трип (Ethno Trip)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Дрим-хаус (Dream House)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Прогрессив-рок (Progressive Rock)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Синти-джаз (Synth Jazz)", new List<int> {2, 1, 2, 2, 1, 1, 2}},
            {"Глитч-дабстеп (Glitch Dubstep)", new List<int> {3, 1, 2, 1, 2, 2, 1}},
            {"Чилл-рок (Chill Rock)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Этно-даунтемпо (Ethno Downtempo)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Техно-трип (Techno Trip)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Нью-блюз (New Blues)", new List<int> {3, 2, 1, 1, 3, 2}},
            {"Дрим-фанк (Dream Funk)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Прогрессив-даб (Progressive Dub)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Синти-эмбиент (Synth Ambient)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Глитч-джаз (Glitch Jazz)", new List<int> {2, 1, 2, 2, 1, 1, 2}},
            {"Чилл-регги (Chill Reggae)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Этно-глиц (Ethno Glitch)", new List<int> {1, 2, 1, 2, 2, 1, 3}},
            {"Техно-рок (Techno Rock)", new List<int> {3, 2, 2, 3, 2}},
            {"Нью-поп (New Pop)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Дрим-даб (Dream Dub)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Прогрессив-эмбиент (Progressive Ambient)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Синти-дабстеп (Synth Dubstep)", new List<int> {3, 1, 2, 1, 2, 2, 1}},
            {"Глитч-регги (Glitch Reggae)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Чилл-джаз (Chill Jazz)", new List<int> {2, 1, 2, 2, 1, 1, 2}},
            {"Этно-фанк (Ethno Funk)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Техно-даунтемпо (Techno Downtempo)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Нью-рок (New Rock)", new List<int> {3, 2, 2, 3, 2}},
            {"Дрим-трип (Dream Trip)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Прогрессив-регги (Progressive Reggae)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Синти-трип (Synth Trip)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Глитч-эмбиент (Glitch Ambient)", new List<int> {1, 2, 1, 2, 2, 1, 3}},
            {"Чилл-фьюжн (Chill Fusion)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Этно-джангл (Ethno Jungle)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Техно-джаз (Techno Jazz)", new List<int> {2, 1, 2, 2, 1, 1, 2}},
            {"Нью-даб (New Dub)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Дрим-джаз (Dream Jazz)", new List<int> {2, 1, 2, 2, 1, 1, 2}},
            {"Прогрессив-фолк (Progressive Folk)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Синти-фолк (Synth Folk)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Глитч-трип (Glitch Trip)", new List<int> {1, 2, 1, 2, 2, 1, 3}},
            {"Чилл-эмбиент (Chill Ambient)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
            {"Этно-хаус (Ethno House)", new List<int> {2, 2, 1, 2, 2, 1, 2}},
            {"Техно-фолк (Techno Folk)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Нью-трип (New Trip)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Дрим-фолк (Dream Folk)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Прогрессив-даунтемпо (Progressive Downtempo)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Синти-даунтемпо (Synth Downtempo)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Глитч-фолк (Glitch Folk)", new List<int> {1, 2, 1, 2, 2, 1, 3}},
            {"Чилл-трип (Chill Trip)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Этно-дабстеп (Ethno Dubstep)", new List<int> {3, 1, 2, 1, 2, 2, 1}},
            {"Техно-трип-хоп (Techno Trip-Hop)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Нью-фанк (New Funk)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Дрим-даунтемпо (Dream Downtempo)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Прогрессив-джангл (Progressive Jungle)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Синти-регги (Synth Reggae)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Глитч-даунтемпо (Glitch Downtempo)", new List<int> {1, 2, 1, 2, 2, 1, 3}},
            {"Чилл-дабстеп (Chill Dubstep)", new List<int> {3, 1, 2, 1, 2, 2, 1}},
            {"Этно-фолк (Ethno Folk)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Техно-даб (Techno Dub)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Нью-джангл (New Jungle)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Дрим-регги (Dream Reggae)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Прогрессив-трип (Progressive Trip)", new List<int> {2, 1, 2, 2, 1, 2, 2}},
            {"Синти-даб (Synth Dub)", new List<int> {2, 2, 1, 2, 2, 2, 1}},
            {"Глитч-джангл (Glitch Jungle)", new List<int> {2, 2, 1, 2, 1, 2, 2}},
            {"Чилл-фолк (Chill Folk)", new List<int> {2, 1, 2, 2, 2, 1, 2}},
            {"Космический минор (Cosmic Minor)", new List<int> {2, 1, 3, 1, 2, 2, 1}},
            {"Глитч-тон (Glitch Tone)", new List<int> {1, 3, 1, 2, 1, 2, 2}},
            {"Дримвейв (Dreamwave)", new List<int> {2, 2, 2, 1, 2, 2, 1}},
            {"Нойз-кор (Noise Core)", new List<int> {1, 2, 1, 2, 1, 3, 2}},
            {"Техно-микс (Techno Mix)", new List<int> {2, 1, 2, 1, 3, 2, 1}}
        }

    },
    {
    "Микротональные лады", new Dictionary<string, List<int>>
    {
        {"Бохлен-Пирс (Bohlen-Pierce)", new List<int> {3, 2, 3, 2, 2}},
        {"Гамма 19-ET (19-Tone Equal Temperament)", new List<int> {2, 1, 2, 1, 2, 2, 2}},
        {"Квартальный лад (Quarter-Tone)", new List<int> {1, 2, 1, 3, 1, 2, 2}}
    }
},
            };
            // Конвертируем все определенные лады в абсолютные интервалы
            foreach (var category in scalePatterns)
            {
                var scales = new Dictionary<string, int[]>();

                foreach (var scale in category.Value)
                {
                    scales[scale.Key] = ConvertToAbsoluteIntervals(scale.Value);
                }

                result[category.Key] = scales;
            }

            return result;
        }

        private Dictionary<string, int[]> CreateStyleSpecificDurations()
        {
            return new Dictionary<string, int[]>(StringComparer.OrdinalIgnoreCase)
    {
        // Each array defines the duration multipliers for notes (1 = sixteenth, 2 = eighth, 4 = quarter, etc.)
        // Jazz styles - more swing feel with varied durations
        { "Jazz", new int[] { 2, 1, 2, 1, 3, 1, 2, 1, 2, 1, 2, 1, 3, 1, 1, 1 } },
        { "Walking Bass", new int[] { 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0 } },
        { "Bebop", new int[] { 3, 1, 2, 1, 2, 1, 2, 1, 3, 1, 2, 1, 2, 1, 1, 1 } },
        
        // Funk styles - shorter, more staccato notes with occasional longer ones
        { "Funk", new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1 } },
        { "Slap", new int[] { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 } },
        { "Soul", new int[] { 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1 } },
        { "R&B", new int[] { 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1 } },
        
        // Rock styles - sustained quarter notes and steady eighth notes
        { "Rock", new int[] { 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0 } },
        { "Hard Rock", new int[] { 3, 0, 2, 0, 3, 0, 2, 0, 3, 0, 2, 0, 3, 0, 2, 0 } },
        { "Metal", new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 } },
        { "Progressive Metal", new int[] { 2, 2, 1, 1, 2, 2, 1, 1, 3, 0, 2, 0, 2, 1, 1, 1 } },
        
        // Reggae styles - longer sustains on off-beats
        { "Reggae", new int[] { 1, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0 } },
        { "Dub", new int[] { 6, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 } },
        { "Blues Shuffle", new int[] { 3, 0, 2, 0, 3, 0, 2, 0, 3, 0, 2, 0, 3, 0, 2, 0 } },
        
        // Latin styles - syncopated with varied durations
        { "Salsa", new int[] { 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1 } },
        { "Bossa Nova", new int[] { 3, 0, 2, 0, 1, 1, 2, 0, 3, 0, 1, 1, 2, 0, 1, 1 } },
        { "Samba", new int[] { 1, 1, 2, 0, 1, 1, 2, 0, 1, 1, 2, 0, 1, 1, 2, 0 } },
        
        // Electronic styles - precise and quantized
        { "House", new int[] { 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0 } },
        { "Techno", new int[] { 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0 } },
        { "Drum & Bass", new int[] { 3, 0, 0, 0, 1, 0, 1, 0, 3, 0, 0, 0, 1, 0, 1, 0 } },
        { "Trance", new int[] { 3, 0, 1, 0, 3, 0, 1, 0, 3, 0, 1, 0, 3, 0, 1, 0 } },
        
        // PsyTrance - все 16 нот одинаковой длительности (шестнадцатые)
        { "PsyTrance", new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 } },

        { "Breakbeat", new int[] { 2, 0, 1, 1, 2, 0, 1, 1, 2, 0, 1, 1, 2, 0, 1, 1 } },
        
        // Progressive Trance styles - added new patterns
        { "Progressive Trance", new int[] { 4, 0, 2, 0, 2, 0, 3, 0, 4, 0, 2, 0, 3, 0, 1, 0 } }, // Dynamic variations with emphasis on build-up
        { "Progressive House", new int[] { 3, 0, 2, 0, 3, 0, 2, 0, 4, 0, 0, 0, 3, 1, 2, 0 } }, // Smooth transitions and sustained notes
        { "Uplifting Trance", new int[] { 2, 0, 3, 0, 2, 0, 3, 0, 4, 0, 0, 0, 2, 0, 3, 0 } }, // Euphoric with sustained climaxes
        { "Goa Trance", new int[] { 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 2, 0, 2, 0 } }, // Psychedelic with organic variations
        { "Tech Trance", new int[] { 2, 0, 2, 0, 1, 0, 2, 1, 2, 0, 2, 0, 1, 0, 3, 0 } }, // Techno influence with trance euphoria
        
        // Hip-hop styles - heavy and sustained
        { "Hip-Hop", new int[] { 4, 0, 0, 0, 2, 0, 2, 0, 4, 0, 0, 0, 2, 0, 2, 0 } },
        { "Trap", new int[] { 6, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0 } },
        { "Lo-Fi", new int[] { 3, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 2, 1, 0, 0 } },
        
        // Classical/traditional styles
        { "Folk", new int[] { 4, 0, 2, 0, 4, 0, 2, 0, 4, 0, 2, 0, 4, 0, 2, 0 } },
        { "Celtic", new int[] { 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1 } },
        
        // Default for other styles - reasonable mix of durations
        { "Default", new int[] { 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1 } }
    };
        }
        // Метод для определения, какую конкретную функцию транс-стиля применить
        private List<int> ApplyTranceVariations(List<int> bassLine, string tranceSubstyle)
        {
            switch (tranceSubstyle.ToLower())
            {
                case "progressive trance":
                    return ApplyProgressiveTranceVariations(bassLine);
                case "uplifting trance":
                    return ApplyUpliftingTranceVariations(bassLine);
                case "goa trance":
                    return ApplyGoaTranceVariations(bassLine);
                case "tech trance":
                    return ApplyTechTranceVariations(bassLine);
                case "progressive house":
                    return ApplyProgressiveHouseVariations(bassLine);
                default:
                    return ApplyGenericTranceVariations(bassLine); // Общие вариации транса
            }
        }
        // Новые специализированные функции для басовых паттернов различных жанров

        // === ФУНКЦИИ ФАНК/СОУЛ/R&B ===
        private List<int> ApplyFunkSoulRBVariations(List<int> bassLine, List<int> scaleNotes)
        {
            var result = new List<int>(bassLine);

            // Фанк, Соул и R&B характеризуются синкопированными ритмами,
            // акцентированием офф-битов и характерной артикуляцией (слэп, поп, глиссандо)

            // 1. Добавляем слэп-артикуляцию на сильные доли с умеренной вероятностью
            for (int i = 0; i < result.Count; i += 4)
            {
                if (result[i] > 0 && random.NextDouble() < 0.6)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);
                    result[i] = 1000 + baseNote; // Слэп-артикуляция
                }
            }

            // 2. Добавляем "ghost notes" (тихие промежуточные ноты) между основными нотами
            for (int i = 1; i < result.Count; i += 2)
            {
                if (result[i] == -1 && i > 0 && result[i - 1] > 0 && random.NextDouble() < 0.3)
                {
                    int baseNote = ExtractBaseNoteValue(result[i - 1]);
                    // Ghost note - обычно на пару полутонов ниже основной ноты
                    result[i] = baseNote - 2;
                }
            }

            // 3. Добавляем синкопирование - акцентируем офф-биты
            for (int i = 2; i < result.Count; i += 4)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);
                    // Усиливаем ноты на офф-битах (особенность фанка)
                    if (random.NextDouble() < 0.7)
                    {
                        result[i] = 2000 + baseNote; // Акцент
                    }
                }
                else if (result[i] == -1)
                {
                    // Если нет ноты на офф-бите, иногда добавляем её
                    if (random.NextDouble() < 0.4 && i > 0)
                    {
                        // Поиск ближайшей ноты для синкопирования
                        for (int j = i - 1; j >= 0; j--)
                        {
                            if (result[j] > 0)
                            {
                                int baseNote = ExtractBaseNoteValue(result[j]);
                                // Добавляем ноту, часто с слэп-артикуляцией
                                result[i] = random.NextDouble() < 0.6 ? 1000 + baseNote : baseNote;
                                break;
                            }
                        }
                    }
                }
            }

            // 4. Добавляем характерные для фанка/соула переходы между нотами
            for (int i = 0; i < result.Count - 1; i++)
            {
                if (result[i] > 0 && result[i + 1] > 0)
                {
                    int currentNote = ExtractBaseNoteValue(result[i]);
                    int nextNote = ExtractBaseNoteValue(result[i + 1]);

                    // Если ноты значительно отличаются, добавляем слайд/глиссандо
                    if (Math.Abs(nextNote - currentNote) > 3 && random.NextDouble() < 0.5)
                    {
                        result[i] = 4000 + currentNote; // Слайд
                    }
                }
            }

            // 5. Специфическая для R&B/соула "колесообразная" басовая линия
            if (random.NextDouble() < 0.3)
            {
                int rootNote = -1;
                // Ищем корневую ноту
                for (int i = 0; i < result.Count; i++)
                {
                    if (result[i] > 0)
                    {
                        rootNote = ExtractBaseNoteValue(result[i]);
                        break;
                    }
                }

                if (rootNote > 0)
                {
                    // Находим ноты гаммы близкие к корневой
                    var nearbyScaleNotes = scaleNotes
                        .Where(n => Math.Abs(n - rootNote) <= 5)
                        .OrderBy(n => Math.Abs(n - rootNote))
                        .ToList();

                    if (nearbyScaleNotes.Count >= 3)
                    {
                        // Создаем типичную для R&B "колесообразную" фигуру в нескольких местах
                        for (int startPos = 4; startPos < result.Count - 4; startPos += 8)
                        {
                            if (random.NextDouble() < 0.7)
                            {
                                // Простой паттерн: корень, верхняя нота, средняя нота, возврат к корню
                                int[] pattern = new int[] {
                            rootNote,
                            nearbyScaleNotes[1],
                            nearbyScaleNotes[2],
                            rootNote
                        };

                                // Применяем паттерн
                                for (int i = 0; i < 4 && (startPos + i) < result.Count; i++)
                                {
                                    result[startPos + i] = pattern[i];
                                }
                            }
                        }
                    }
                }
            }

            return result;
        }

        // === ФУНКЦИИ ХИПХОП/ТРЭП ===
        private List<int> ApplyHipHopTrapVariations(List<int> bassLine, List<int> scaleNotes)
        {
            var result = new List<int>(bassLine);

            // Хип-хоп и Трэп характеризуются глубокими, протяжёнными басами,
            // "808" басовыми дропами и ритмическими паттернами

            // 1. Находим корневую ноту для создания суб-баса
            int rootNote = -1;
            for (int i = 0; i < result.Count; i++)
            {
                if (result[i] > 0)
                {
                    rootNote = ExtractBaseNoteValue(result[i]);
                    break;
                }
            }

            if (rootNote > 0)
            {
                // 2. Создаем устойчивую суб-басовую линию для хип-хопа
                // Типично для хип-хопа - продолжительные низкие ноты
                for (int i = 0; i < result.Count; i += 4)
                {
                    if (random.NextDouble() < 0.6) // 60% шанс для каждой сильной доли
                    {
                        // Очищаем несколько нот вперед для создания продолжительного суб-баса
                        int sustainLength = random.Next(2, 4);

                        // Создаем суб-бас (часто на октаву ниже)
                        int subBassNote = rootNote - 12;

                        // Убедимся, что нота не слишком низкая
                        if (subBassNote < 28) subBassNote = 28;

                        // Устанавливаем суб-бас с глубоким звучанием (используем артикуляцию)
                        result[i] = 2000 + subBassNote; // Акцентированный суб-бас

                        // Очищаем следующие позиции для создания продолжительного эффекта
                        for (int j = 1; j <= sustainLength && (i + j) < result.Count; j++)
                        {
                            result[i + j] = -1;
                        }
                    }
                }

                // 3. Добавляем характерные для Трэпа "скольжения" (glides) и "808 rolls"
                if (random.NextDouble() < 0.4) // 40% шанс добавления
                {
                    // Позиция для добавления трэп-элемента
                    int trapPos = random.Next(4, 12);

                    // Проверяем, что позиция существует
                    if (trapPos < result.Count)
                    {
                        // Выбираем между глиссандо и "808 roll"
                        if (random.NextDouble() < 0.5)
                        {
                            // Глиссандо - характерное скольжение вниз
                            int glideNote = rootNote - 5; // Обычно на несколько полутонов ниже
                            result[trapPos] = 4000 + glideNote; // Glide эффект
                        }
                        else
                        {
                            // "808 roll" - быстрое повторение низкой ноты
                            for (int i = 0; i < 3 && (trapPos + i) < result.Count; i++)
                            {
                                result[trapPos + i] = rootNote - 12; // Суб-бас
                            }
                        }
                    }
                }
            }

            // 4. Добавляем характерные для хип-хопа паузы (создание пространства в миксе)
            for (int i = 0; i < result.Count; i++)
            {
                // Создаем паузы в определенных местах для типичного хип-хоп ритма
                if (i % 8 >= 5 && i % 8 <= 6 && result[i] > 0 && random.NextDouble() < 0.6)
                {
                    result[i] = -1; // Пауза
                }
            }

            // 5. Добавляем трэп-специфические "бас-дропы" в конце секции
            if (random.NextDouble() < 0.5)
            {
                // Типичная позиция для бас-дропа
                int dropPos = result.Count - 4;

                if (dropPos > 0 && rootNote > 0)
                {
                    // Специфический для трэпа эффект "бас-дропа"
                    int dropNote = rootNote - 12; // Октавой ниже

                    // Акцентируем дроп
                    result[dropPos] = 2000 + dropNote;

                    // Добавляем глиссандо после дропа
                    if (dropPos + 1 < result.Count)
                    {
                        result[dropPos + 1] = 4000 + (dropNote - 2); // Глиссандо вниз
                    }
                }
            }

            return result;
        }

        // === ФУНКЦИИ РОК/МЕТАЛ ===
        private List<int> ApplyRockMetalVariations(List<int> bassLine, List<int> scaleNotes)
        {
            var result = new List<int>(bassLine);

            // Рок и Метал характеризуются агрессивными, ритмичными басовыми линиями,
            // с акцентом на сильные доли, техникой palm muting и педальными тонами

            // 1. Находим основные ноты
            List<int> uniqueNotes = result.Where(n => n > 0)
                                         .Select(n => ExtractBaseNoteValue(n))
                                         .Distinct()
                                         .ToList();

            // Если нет нот, возвращаем оригинальную линию
            if (!uniqueNotes.Any())
                return result;

            // Базовая нота (обычно самая низкая)
            int baseNote = uniqueNotes.Min();

            // 2. Добавляем palm muting - типичную металлическую/роковую технику
            for (int i = 0; i < result.Count; i += 2)
            {
                if (result[i] > 0)
                {
                    int noteValue = ExtractBaseNoteValue(result[i]);

                    // Palm Muting на чётных позициях (имитируем через pull-off артикуляцию)
                    if (random.NextDouble() < 0.6)
                    {
                        result[i] = 3000 + noteValue;
                    }
                }
            }

            // 3. Добавляем педальные тона (повторяющиеся басовые ноты) - характерно для хэви-метала
            if (random.NextDouble() < 0.7) // 70% шанс
            {
                // Выбираем секцию для педальных тонов
                int pedalStart = random.Next(0, 8);
                int pedalLength = random.Next(4, 8);

                // Убедимся, что не выходим за пределы
                pedalLength = Math.Min(pedalLength, result.Count - pedalStart);

                // Создаем педальный тон
                for (int i = 0; i < pedalLength; i += 2)
                {
                    int pos = pedalStart + i;
                    if (pos < result.Count)
                    {
                        result[pos] = baseNote; // Базовая нота как педальный тон

                        // Каждый второй педальный тон с акцентом для динамики
                        if (i % 4 == 0)
                        {
                            result[pos] = 2000 + baseNote; // Акцентированный педальный тон
                        }
                    }
                }
            }

            // 4. Добавляем gallop паттерны - характерные для трэш/пауэр-метала
            if (random.NextDouble() < 0.4) // 40% шанс
            {
                // Позиция для gallop паттерна
                int gallopStart = random.Next(0, result.Count - 6);

                // Создаем gallop паттерн (быстрые ноты)
                if (gallopStart >= 0)
                {
                    // Очищаем несколько позиций для gallop
                    for (int i = 0; i < 6 && (gallopStart + i) < result.Count; i++)
                    {
                        result[gallopStart + i] = -1;
                    }

                    // Создаем типичный gallop: БУМ-бам-бам (БУМ-бам-бам) - где БУМ акцентирован
                    result[gallopStart] = 2000 + baseNote; // Акцентированная первая нота
                    result[gallopStart + 2] = baseNote; // Вторая нота
                    result[gallopStart + 3] = baseNote; // Третья нота

                    // Повторяем если есть место
                    if (gallopStart + 5 < result.Count)
                    {
                        result[gallopStart + 4] = 2000 + baseNote;
                    }
                }
            }

            // 5. Добавляем характерные для хэви/пауэр-метала power chord подходы
            for (int i = 0; i < result.Count - 3; i += 4)
            {
                if (result[i] > 0 && random.NextDouble() < 0.5)
                {
                    int currentNote = ExtractBaseNoteValue(result[i]);

                    // Находим квинту в рамках гаммы
                    int fifthNote = scaleNotes.FirstOrDefault(n => Math.Abs(n - (currentNote + 7)) <= 1);

                    if (fifthNote > 0)
                    {
                        // Создаем power chord подход
                        if (i + 1 < result.Count)
                        {
                            result[i + 1] = fifthNote;
                        }

                        // Иногда добавляем характерный хроматический спуск
                        if (i + 2 < result.Count && random.NextDouble() < 0.3)
                        {
                            result[i + 2] = currentNote - 1; // Полутон вниз
                        }
                    }
                }
            }

            // 6. Для особой агрессивности, добавляем акценты на сильных долях
            for (int i = 0; i < result.Count; i += 4)
            {
                if (result[i] > 0 && result[i] < 1000)
                {
                    // Акцентирование сильных долей - очень характерно для метала
                    int noteValue = ExtractBaseNoteValue(result[i]);
                    result[i] = 2000 + noteValue; // Hammer-on для сильного акцента
                }
            }

            return result;
        }

        // === ФУНКЦИИ РЕГГИ/ДАБ ===
        private List<int> ApplyReggaeDubVariations(List<int> bassLine, List<int> scaleNotes)
        {
            var result = new List<int>(bassLine);

            // Регги и даб характеризуются глубокими басами с акцентом на офф-битах,
            // пространственными эффектами и узнаваемым "one drop" ритмом

            // Базовые ноты регги часто проще, но глубже

            // 1. Создаем типичный для регги паттерн с акцентом на офф-битах (1 & 3)
            for (int i = 0; i < result.Count; i++)
            {
                // Очищаем некоторые сильные доли для создания "one drop" эффекта
                if (i % 4 == 0 && result[i] > 0 && random.NextDouble() < 0.7)
                {
                    result[i] = -1; // Удаляем ноту на сильной доле
                }

                // Добавляем акцент на офф-биты (2-я и 4-я доли) - характерно для регги
                if ((i % 4 == 1 || i % 4 == 3) && result[i] > 0)
                {
                    int noteValue = ExtractBaseNoteValue(result[i]);
                    result[i] = 2000 + noteValue; // Акцентируем офф-биты
                }
            }

            // 2. Создаем типичный для регги "skank" - короткие аккорды на офф-битах
            for (int i = 0; i < result.Count; i += 2)
            {
                // На офф-битах часто есть аккордные ноты
                if (i % 4 != 0 && result[i] == -1 && random.NextDouble() < 0.5)
                {
                    // Находим ближайшую базовую ноту для создания skank
                    int refNote = -1;
                    for (int j = Math.Max(0, i - 4); j < Math.Min(result.Count, i + 4); j++)
                    {
                        if (result[j] > 0)
                        {
                            refNote = ExtractBaseNoteValue(result[j]);
                            break;
                        }
                    }

                    if (refNote > 0)
                    {
                        // Добавляем skank ноту (обычно терция или квинта от базовой ноты)
                        int[] reggaeIntervals = { 3, 5, 7 }; // Минорная терция, кварта или квинта
                        int interval = reggaeIntervals[random.Next(reggaeIntervals.Length)];

                        // Проверяем, чтобы нота была в гамме
                        int skankNote = refNote + interval;
                        if (IsNoteInScale(skankNote, scaleNotes))
                        {
                            result[i] = skankNote;
                        }
                        else
                        {
                            // Если не в гамме, находим ближайшую ноту в гамме
                            result[i] = FindClosestNoteInScale(skankNote, scaleNotes);
                        }
                    }
                }
            }

            // 3. Для даб-стиля - добавляем эхо-эффекты и пространственные трюки
            if (random.NextDouble() < 0.4) // 40% шанс применения даб-эффектов
            {
                // Выбираем секцию для даб эффекта
                int dubSection = random.Next(0, result.Count - 8);

                if (dubSection >= 0)
                {
                    // Находим базовую ноту
                    int dubRootNote = -1;
                    for (int i = dubSection; i < dubSection + 8 && i < result.Count; i++)
                    {
                        if (result[i] > 0)
                        {
                            dubRootNote = ExtractBaseNoteValue(result[i]);
                            break;
                        }
                    }

                    if (dubRootNote > 0)
                    {
                        // Создаем эхо-эффект - постепенно затухающее повторение ноты
                        for (int i = 0; i < 6; i += 2)
                        {
                            int echoPos = dubSection + i;
                            if (echoPos < result.Count)
                            {
                                result[echoPos] = dubRootNote;

                                // Добавляем эффект пространственности через артикуляцию
                                if (i > 0) // Не на первую ноту
                                {
                                    // Создаем эффект затухания через pull-off (более мягкий звук)
                                    result[echoPos] = 3000 + dubRootNote;
                                }
                            }
                        }
                    }
                }
            }

            // 4. Добавляем характерные для регги "slides" - плавные переходы между нотами
            for (int i = 0; i < result.Count - 1; i++)
            {
                if (result[i] > 0 && result[i + 1] > 0)
                {
                    int currentNote = ExtractBaseNoteValue(result[i]);
                    int nextNote = ExtractBaseNoteValue(result[i + 1]);

                    // Если ноты заметно отличаются - добавляем slide
                    if (Math.Abs(nextNote - currentNote) > 2 && random.NextDouble() < 0.6)
                    {
                        result[i] = 4000 + currentNote; // Slide эффект
                    }
                }
            }

            // 5. Для глубокого регги-звучания иногда дублируем ноты октавой ниже
            if (random.NextDouble() < 0.3)
            {
                for (int i = 0; i < result.Count; i += 4)
                {
                    if (result[i] > 0)
                    {
                        int noteValue = ExtractBaseNoteValue(result[i]);

                        // Смещаем на октаву вниз для глубины звучания
                        int deepNote = noteValue - 12;

                        // Проверка на выход за пределы диапазона
                        if (deepNote >= 28) // Нижний предел баса
                        {
                            result[i] = deepNote;
                        }
                    }
                }
            }

            return result;
        }

        // === ФУНКЦИИ ДЖАЗ/БЛЮЗ ===
        private List<int> ApplyJazzBluesVariations(List<int> bassLine, List<int> scaleNotes)
        {
            var result = new List<int>(bassLine);

            // Джаз и блюз характеризуются walking bass паттернами,
            // частым использованием хроматических проходящих нот и триольной пульсацией

            // 1. Создаем хроматические подходы к целевым нотам (характерно для walking bass)
            for (int i = 0; i < result.Count - 1; i++)
            {
                if (result[i] > 0 && result[i + 1] > 0)
                {
                    int currentNote = ExtractBaseNoteValue(result[i]);
                    int nextNote = ExtractBaseNoteValue(result[i + 1]);

                    // Если между нотами расстояние больше полутона, иногда добавляем хроматический подход
                    if (Math.Abs(nextNote - currentNote) > 1 && i + 2 < result.Count && result[i + 2] == -1 && random.NextDouble() < 0.4)
                    {
                        // Хроматический подход снизу или сверху
                        int approachNote;
                        if (nextNote > currentNote)
                        {
                            approachNote = nextNote - 1; // Подход снизу
                        }
                        else
                        {
                            approachNote = nextNote + 1; // Подход сверху
                        }

                        result[i + 2] = approachNote;
                    }
                }
            }

            // 2. Добавляем Blues Notes (характерные блюзовые ноты) в соответствующих местах
            List<int> bluesIntervals = new List<int> { 3, 6, 10 }; // Минорная терция, тритон, минорная септима

            for (int i = 0; i < result.Count; i += 4)
            {
                if (i + 1 < result.Count && result[i] > 0 && result[i + 1] == -1 && random.NextDouble() < 0.3)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Выбираем случайный блюзовый интервал
                    int bluesInterval = bluesIntervals[random.Next(bluesIntervals.Count)];
                    int bluesNote = baseNote + bluesInterval;

                    // Добавляем блюзовую ноту с характерной артикуляцией
                    result[i + 1] = 4000 + bluesNote; // Слайд для блюзового ощущения
                }
            }

            // 3. Создаем джазовые walking bass линии с акцентом на 2-ю и 4-ю доли
            for (int i = 0; i < result.Count; i++)
            {
                // Акцентируем 2-ю и 4-ю доли такта
                if ((i % 16 == 4 || i % 16 == 12) && result[i] > 0 && random.NextDouble() < 0.7)
                {
                    int noteValue = ExtractBaseNoteValue(result[i]);
                    result[i] = 2000 + noteValue; // Лёгкий акцент
                }
            }

            // 4. Добавляем переходящие тона (гармонические заполнения) между аккордами
            for (int i = 3; i < result.Count; i += 4)
            {
                if (result[i] > 0 && i + 1 < result.Count && result[i + 1] > 0)
                {
                    int currentNote = ExtractBaseNoteValue(result[i]);
                    int nextNote = ExtractBaseNoteValue(result[i + 1]);

                    // Если ноты на расстоянии большем, чем терция
                    if (Math.Abs(nextNote - currentNote) > 3 && random.NextDouble() < 0.5)
                    {
                        // Определяем направление движения
                        int direction = Math.Sign(nextNote - currentNote);

                        // Находим промежуточные ноты гаммы
                        var intermediateNotes = scaleNotes
                            .Where(n => (direction > 0 && n > currentNote && n < nextNote) ||
                                        (direction < 0 && n < currentNote && n > nextNote))
                            .OrderBy(n => Math.Abs(n - currentNote))
                            .ToList();

                        // Добавляем промежуточную ноту, если найдена
                        if (intermediateNotes.Any() && i + 2 < result.Count && result[i + 2] == -1)
                        {
                            result[i + 2] = intermediateNotes.First();
                        }
                    }
                }
            }

            // 5. Добавляем триольное чувство для джазового свинга
            for (int i = 0; i < result.Count - 2; i += 4)
            {
                if (result[i] > 0 && result[i + 1] == -1 && result[i + 2] == -1 && random.NextDouble() < 0.4)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Создаем триольную фигуру из близких нот гаммы
                    var nearbyScaleNotes = scaleNotes
                        .Where(n => Math.Abs(n - baseNote) <= 7 && n != baseNote)
                        .OrderBy(n => Math.Abs(n - baseNote))
                        .Take(2)
                        .ToList();

                    if (nearbyScaleNotes.Count >= 2)
                    {
                        // Добавляем "swing" чувство через триольный паттерн
                        result[i + 1] = nearbyScaleNotes[0];
                        result[i + 2] = nearbyScaleNotes[1];
                    }
                }
            }

            // 6. Для блюзового звучания добавляем характерный "shuffle"
            if (random.NextDouble() < 0.5)
            {
                for (int i = 0; i < result.Count; i += 8)
                {
                    if (i + 7 < result.Count)
                    {
                        // Находим ключевые ноты в текущем сегменте
                        List<int> segmentNotes = new List<int>();
                        for (int j = i; j < i + 8; j++)
                        {
                            if (result[j] > 0)
                            {
                                segmentNotes.Add(ExtractBaseNoteValue(result[j]));
                            }
                        }

                        if (segmentNotes.Count >= 2)
                        {
                            // Создаем блюзовый shuffle паттерн
                            int rootNote = segmentNotes.First();
                            int fifthNote = scaleNotes.FirstOrDefault(n => Math.Abs(n - (rootNote + 7)) <= 1);

                            if (fifthNote > 0)
                            {
                                // Типичный блюзовый shuffle паттерн
                                result[i] = rootNote;
                                result[i + 2] = fifthNote;
                                result[i + 4] = rootNote;
                                result[i + 6] = fifthNote - 2; // Характерный блюзовый спуск
                            }
                        }
                    }
                }
            }

            return result;
        }

        // === ФУНКЦИИ ЛАТИНО (САЛЬСА, БОССА-НОВА) ===
        private List<int> ApplyLatinoVariations(List<int> bassLine, List<int> scaleNotes)
        {
            var result = new List<int>(bassLine);

            // Латиноамериканские стили характеризуются синкопированными ритмами,
            // характерными клавэ-паттернами и повторяющимися басовыми фигурами

            // 1. Определяем базовую ноту
            int rootNote = -1;
            for (int i = 0; i < result.Count; i++)
            {
                if (result[i] > 0)
                {
                    rootNote = ExtractBaseNoteValue(result[i]);
                    break;
                }
            }

            if (rootNote <= 0)
                return result; // Если нет базовой ноты, возвращаем оригинал

            // 2. Создаем типичный для сальсы "tumbao" паттерн
            if (random.NextDouble() < 0.6) // 60% шанс
            {
                // Классическая фигура tumbao на основе клавэ 3-2
                int[] tumbaoRhythm = { 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0 };

                // Выбираем ноты для паттерна
                int fifth = scaleNotes.FirstOrDefault(n => Math.Abs(n - (rootNote + 7)) <= 1);

                if (fifth > 0)
                {
                    // Применяем tumbao к части басовой линии
                    for (int i = 0; i < result.Count && i < tumbaoRhythm.Length; i++)
                    {
                        if (tumbaoRhythm[i] == 1)
                        {
                            // Чередуем корень и квинту для создания типичного tumbao
                            if (i % 4 == 0)
                            {
                                result[i] = rootNote;
                            }
                            else
                            {
                                result[i] = fifth;
                            }

                            // Добавляем некоторую артикуляцию
                            if (random.NextDouble() < 0.4)
                            {
                                result[i] = 1000 + result[i]; // Слэп для яркости
                            }
                        }
                        else if (result[i] > 0)
                        {
                            // Если ритм tumbao не предполагает ноту здесь, но она есть,
                            // часто её удаляем для сохранения tumbao характера
                            if (random.NextDouble() < 0.7)
                            {
                                result[i] = -1;
                            }
                        }
                    }
                }
            }

            // 3. Создаем типичный для босса-новы "syncopated" паттерн
            else
            {
                // Босса-нова имеет более смягченный синкопированный паттерн
                int[] bossaNovaRhythm = { 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1 };

                // Выбираем ноты для паттерна
                int fifth = scaleNotes.FirstOrDefault(n => Math.Abs(n - (rootNote + 7)) <= 1);
                int major3rd = scaleNotes.FirstOrDefault(n => Math.Abs(n - (rootNote + 4)) <= 1);
                int minor7th = scaleNotes.FirstOrDefault(n => Math.Abs(n - (rootNote + 10)) <= 1);

                // Создаем набор нот для использования в боссанове
                List<int> bossaNovaNotes = new List<int>();
                if (rootNote > 0) bossaNovaNotes.Add(rootNote);
                if (fifth > 0) bossaNovaNotes.Add(fifth);
                if (major3rd > 0) bossaNovaNotes.Add(major3rd);
                if (minor7th > 0) bossaNovaNotes.Add(minor7th);

                // Если не удалось найти нужные ноты, используем доступные из гаммы
                if (bossaNovaNotes.Count < 3)
                {
                    bossaNovaNotes = scaleNotes
                        .Where(n => Math.Abs(n - rootNote) <= 12)
                        .OrderBy(n => Math.Abs(n - rootNote))
                        .Take(4)
                        .ToList();
                }

                if (bossaNovaNotes.Count >= 2)
                {
                    // Применяем босса-нова ритм
                    for (int i = 0; i < result.Count && i < bossaNovaRhythm.Length; i++)
                    {
                        if (bossaNovaRhythm[i] == 1)
                        {
                            // Типичная для босса-нова смена нот в паттерне
                            int noteIndex = (i / 2) % bossaNovaNotes.Count;
                            result[i] = bossaNovaNotes[noteIndex];

                            // Босса-нова имеет более мягкую артикуляцию
                            if (i % 4 == 0 && random.NextDouble() < 0.3)
                            {
                                result[i] = 2000 + result[i]; // Лёгкий акцент
                            }
                        }
                        else if (result[i] > 0)
                        {
                            // Часто убираем ноты вне паттерна
                            if (random.NextDouble() < 0.6)
                            {
                                result[i] = -1;
                            }
                        }
                    }
                }
            }

            // 4. Добавляем характерные для латино глиссандо
            for (int i = 0; i < result.Count - 1; i++)
            {
                if (result[i] > 0 && result[i + 1] > 0)
                {
                    int currentNote = ExtractBaseNoteValue(result[i]);
                    int nextNote = ExtractBaseNoteValue(result[i + 1]);

                    // Добавляем скольжение между нотами (характерно для латинского стиля)
                    if (Math.Abs(nextNote - currentNote) > 2 && random.NextDouble() < 0.5)
                    {
                        result[i] = 4000 + currentNote; // Slide effect
                    }
                }
            }

            // 5. Добавляем "montuno" мотивы - типичные для сальсы и латины повторяющиеся фигуры
            if (random.NextDouble() < 0.4)
            {
                // Выбираем участок для montuno
                int montunoStart = random.Next(0, result.Count - 8);

                if (montunoStart >= 0)
                {
                    // Создаем простой montuno мотив
                    List<int> montunoPattern = new List<int>();

                    // Находим доступные ноты для montuno
                    var montunoNotes = scaleNotes
                        .Where(n => Math.Abs(n - rootNote) <= 12)
                        .OrderBy(n => Math.Abs(n - rootNote))
                        .Take(4)
                        .ToList();

                    if (montunoNotes.Count >= 3)
                    {
                        // Типичный montuno паттерн из 4 нот
                        montunoPattern.Add(montunoNotes[0]); // Корень
                        montunoPattern.Add(montunoNotes[2]); // Обычно квинта
                        montunoPattern.Add(montunoNotes[0]); // Повтор корня
                        montunoPattern.Add(montunoNotes[1]); // Обычно терция

                        // Применяем паттерн к выбранному участку
                        for (int i = 0; i < 8 && (montunoStart + i) < result.Count; i++)
                        {
                            if (i % 2 == 0) // На четные позиции ставим ноты montuno
                            {
                                result[montunoStart + i] = montunoPattern[i / 2 % montunoPattern.Count];

                                // Характерные для montuno акценты
                                if (i == 0 || i == 4)
                                {
                                    result[montunoStart + i] = 2000 + result[montunoStart + i]; // Акцент
                                }
                            }
                            else if (result[montunoStart + i] > 0 && random.NextDouble() < 0.7)
                            {
                                // Удаляем большинство нот, не входящих в паттерн
                                result[montunoStart + i] = -1;
                            }
                        }
                    }
                }
            }

            return result;
        }

        // === ФУНКЦИИ ЭЛЕКТРОНИКА (ХАУС, ТЕХНО) ===
        private List<int> ApplyElectronicVariations(List<int> bassLine, List<int> scaleNotes)
        {
            var result = new List<int>(bassLine);

            // Электронная музыка характеризуется четкими ритмическими структурами,
            // повторяющимися мотивами и часто фильтр-свипами и эффектами

            // 1. Определяем базовую ноту
            int rootNote = -1;
            for (int i = 0; i < result.Count; i++)
            {
                if (result[i] > 0)
                {
                    rootNote = ExtractBaseNoteValue(result[i]);
                    break;
                }
            }

            // Если не удалось найти базовую ноту, возвращаем оригинал
            if (rootNote <= 0)
                return result;

            // 2. Четкий хаус-патерн - акцент на каждую долю (four-on-the-floor)
            if (random.NextDouble() < 0.5) // Хаус вариант
            {
                // Четкий хаус бит
                for (int i = 0; i < result.Count; i += 4)
                {
                    if (i < result.Count)
                    {
                        // Устанавливаем корневую ноту на каждую четверть
                        result[i] = rootNote;

                        // Характерная для хауса артикуляция
                        if (random.NextDouble() < 0.3)
                        {
                            result[i] = 2000 + rootNote; // Акцент
                        }

                        // Добавляем октавные вариации - типично для хауса
                        if (i + 2 < result.Count && result[i + 2] == -1 && random.NextDouble() < 0.4)
                        {
                            result[i + 2] = rootNote + 12; // Октава вверх на офф-бит
                        }
                    }
                }

                // Добавляем характерные для хауса "fills" (заполнения)
                int fillPosition = random.Next(8, 14);
                if (fillPosition < result.Count - 2)
                {
                    // Хаус филл обычно состоит из быстрых нот
                    result[fillPosition] = rootNote;
                    result[fillPosition + 1] = rootNote + 12; // Октава вверх
                    result[fillPosition + 2] = rootNote + 7; // Квинта
                }
            }
            // 3. Техно-паттерн - более акцентированный и механический
            else
            {
                // Для техно характерны более механические паттерны
                for (int i = 0; i < result.Count; i += 2)
                {
                    if (i < result.Count)
                    {
                        // Устанавливаем ноты на каждую восьмую для жесткого техно-звучания
                        if (random.NextDouble() < 0.7) // 70% вероятность ноты (для создания паттерна)
                        {
                            // Выбираем между корнем и квинтой для техно-звучания
                            int techNote = (i % 8 == 0 || i % 8 == 4) ? rootNote : (rootNote + 7);

                            // Проверяем, что нота в гамме
                            if (!IsNoteInScale(techNote, scaleNotes))
                            {
                                techNote = FindClosestNoteInScale(techNote, scaleNotes);
                            }

                            result[i] = techNote;

                            // Акцентируем ключевые позиции
                            if (i % 8 == 0)
                            {
                                result[i] = 2000 + techNote; // Сильный акцент на первую долю
                            }
                        }
                        else if (result[i] > 0)
                        {
                            // Убираем некоторые существующие ноты для создания техно-паттерна
                            result[i] = -1;
                        }
                    }
                }

                // Добавляем техно-свип (характерный фильтр-эффект)
                if (random.NextDouble() < 0.5)
                {
                    int sweepStart = random.Next(4, 12);
                    if (sweepStart < result.Count - 4)
                    {
                        // Создаем ascending или descending свип
                        bool ascending = random.NextDouble() < 0.5;

                        for (int i = 0; i < 4; i++)
                        {
                            int pos = sweepStart + i;
                            if (pos < result.Count)
                            {
                                int sweepNote = ascending ?
                                    (rootNote + i * 2) : // Восходящий свип
                                    (rootNote + (3 - i) * 2); // Нисходящий свип

                                // Проверяем, что нота в гамме
                                if (!IsNoteInScale(sweepNote, scaleNotes))
                                {
                                    sweepNote = FindClosestNoteInScale(sweepNote, scaleNotes);
                                }

                                result[pos] = sweepNote;

                                // Добавляем эффект скольжения для свипа
                                if (i < 3) // Не для последней ноты
                                {
                                    result[pos] = 4000 + sweepNote; // Slide effect
                                }
                            }
                        }
                    }
                }
            }

            // 4. Добавляем сайд-чейн эффект - характерные для электронной музыки "провалы" в басу
            for (int i = 0; i < result.Count; i += 8)
            {
                // Сайд-чейн обычно влияет на офф-биты
                for (int j = 1; j <= 3; j++)
                {
                    int pos = i + j;
                    if (pos < result.Count && result[pos] > 0 && random.NextDouble() < 0.7)
                    {
                        // Эмулируем сайд-чейн эффект удалением нот на определенных позициях
                        result[pos] = -1;
                    }
                }
            }

            // 5. Добавляем арпеджированные фигуры - характерны для различных электронных жанров
            if (random.NextDouble() < 0.4)
            {
                int arpeggioStart = random.Next(0, result.Count - 8);

                if (arpeggioStart >= 0)
                {
                    // Создаем арпеджио на основе корневой ноты
                    var arpeggioNotes = scaleNotes
                        .Where(n => Math.Abs(n - rootNote) <= 12 && n >= rootNote)
                        .OrderBy(n => n)
                        .Take(4)
                        .ToList();

                    if (arpeggioNotes.Count >= 3)
                    {
                        // Создаем типичный электронный арпеджио паттерн
                        for (int i = 0; i < 8 && (arpeggioStart + i) < result.Count; i++)
                        {
                            if (i % 2 == 0) // Равномерное арпеджио на шестнадцатых
                            {
                                int noteIndex = (i / 2) % arpeggioNotes.Count;
                                result[arpeggioStart + i] = arpeggioNotes[noteIndex];

                                // Добавляем артикуляции
                                if (i == 0) // Первая нота акцентирована
                                {
                                    result[arpeggioStart + i] = 2000 + result[arpeggioStart + i];
                                }
                                else if (random.NextDouble() < 0.3)
                                {
                                    // Добавляем скольжения между нотами для плавности
                                    result[arpeggioStart + i] = 4000 + result[arpeggioStart + i];
                                }
                            }
                            else if (result[arpeggioStart + i] > 0)
                            {
                                // Убираем ноты вне арпеджио
                                result[arpeggioStart + i] = -1;
                            }
                        }
                    }
                }
            }

            // 6. Добавляем повторяющиеся ноты для характерной электронной "пульсации"
            if (random.NextDouble() < 0.5)
            {
                // Выбираем секцию для пульсации
                int pulseStart = random.Next(0, 8);

                for (int i = pulseStart; i < result.Count; i += 8)
                {
                    // Создаем простую пульсирующую фигуру
                    if (i + 3 < result.Count)
                    {
                        result[i] = rootNote;
                        result[i + 2] = rootNote;

                        // Иногда чередуем с квинтой для вариации
                        if (random.NextDouble() < 0.4)
                        {
                            int fifthNote = scaleNotes.FirstOrDefault(n => Math.Abs(n - (rootNote + 7)) <= 1);
                            if (fifthNote > 0)
                            {
                                result[i + 2] = fifthNote;
                            }
                        }
                    }
                }
            }

            return result;
        }

        private List<int> ApplyProgressiveTranceVariations(List<int> bassLine)
        {
            var result = new List<int>(bassLine);

            // Progressive Trance характеризуется постепенным нарастанием 
            // и усложнением паттерна к концу фразы

            // 1. Начинаем с простого паттерна в первой четверти
            for (int i = 0; i < 4; i++)
            {
                if (result[i] > 0)
                {
                    // Основная нота без изменений или с лёгкой артикуляцией
                    int baseNote = ExtractBaseNoteValue(result[i]);
                    result[i] = random.NextDouble() < 0.2 ? 2000 + baseNote : baseNote;
                }
            }

            // 2. Добавляем небольшие вариации во второй четверти
            for (int i = 4; i < 8; i++)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Иногда добавляем эффект скольжения для плавности
                    if (random.NextDouble() < 0.3)
                    {
                        result[i] = 4000 + baseNote; // Эффект скольжения
                    }
                    // Или делаем акцент
                    else if (random.NextDouble() < 0.4)
                    {
                        result[i] = 2000 + baseNote; // Акцент на ноте
                    }
                }
            }

            // 3. Третья четверть - более выраженные фильтр-свипы и вариации
            for (int i = 8; i < 12; i++)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Применяем более агрессивные артикуляции
                    if (random.NextDouble() < 0.5)
                    {
                        // Если следующая нота существует, создаем "свип" эффект
                        if (i < 11 && result[i + 1] > 0)
                        {
                            result[i] = 4000 + baseNote; // Скольжение к следующей ноте
                        }
                        else
                        {
                            result[i] = 2000 + baseNote; // Акцент
                        }
                    }
                }
            }

            // 4. Последняя четверть - кульминация с наиболее сложными вариациями
            for (int i = 12; i < 16; i++)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Финальные ноты с особыми эффектами
                    double variation = random.NextDouble();

                    if (variation < 0.3)
                    {
                        result[i] = 4000 + baseNote; // Скольжение
                    }
                    else if (variation < 0.6)
                    {
                        result[i] = 2000 + baseNote; // Акцент
                    }
                    else if (variation < 0.7)
                    {
                        // Добавляем тремоло-подобный эффект - очень короткие ноты
                        if (i < 15 && result[i + 1] == -1)
                        {
                            result[i + 1] = baseNote; // Повторяем ноту
                        }
                    }
                }
            }

            // 5. Типичный для прогрессив-транса эффект - фильтр-свип на кульминации
            if (random.NextDouble() < 0.7)
            {
                // Находим хорошую позицию для свипа - обычно пред-финальная нота
                for (int i = 14; i >= 12; i--)
                {
                    if (result[i] > 0)
                    {
                        int baseNote = ExtractBaseNoteValue(result[i]);
                        result[i] = 4000 + baseNote; // Эффект скольжения
                        break;
                    }
                }
            }

            return result;
        }

        private List<int> ApplyUpliftingTranceVariations(List<int> bassLine)
        {
            var result = new List<int>(bassLine);

            // Uplifting Trance характеризуется ярко выраженными подъемами и спадами,
            // чистыми, энергичными нотами и особым вниманием к мелодии

            // 1. Сильные акценты на ключевых нотах
            for (int i = 0; i < result.Count; i += 4)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);
                    // Сильный акцент на каждой сильной доле
                    result[i] = 2000 + baseNote;
                }
            }

            // 2. Создаем "подъемы" для готовности к эйфорической кульминации
            // Обычно во второй половине такта
            for (int i = 8; i < 16; i++)
            {
                if (result[i] > 0 && result[i] < 1000)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Для нот на 3/4 такта добавляем специальный эффект "подъема"
                    if (i >= 12)
                    {
                        // Если следующая нота выше - добавляем скольжение
                        if (i < 15 && result[i + 1] > 0)
                        {
                            int nextBaseNote = ExtractBaseNoteValue(result[i + 1]);
                            if (nextBaseNote > baseNote)
                            {
                                result[i] = 4000 + baseNote; // Эффект скольжения вверх
                            }
                        }
                    }
                }
            }

            // 3. Характерное для Uplifting стаккато в ключевых точках 
            for (int i = 2; i < result.Count; i += 4)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Применяем стаккато и акцентированные ноты
                    if (random.NextDouble() < 0.6)
                    {
                        result[i] = 1000 + baseNote; // Стаккато-подобный эффект
                    }
                }
            }

            // 4. Добавляем характерное для апфлитинга нарастание к финалу
            int finalEmphasizedNote = -1;
            for (int i = 14; i >= 12; i--)
            {
                if (result[i] > 0)
                {
                    finalEmphasizedNote = i;
                    break;
                }
            }

            // Если нашли финальную ноту, создаем к ней подготовку
            if (finalEmphasizedNote > 0)
            {
                for (int i = finalEmphasizedNote - 2; i < finalEmphasizedNote; i++)
                {
                    if (i >= 0 && result[i] > 0)
                    {
                        int baseNote = ExtractBaseNoteValue(result[i]);
                        result[i] = 2000 + baseNote; // Акцентируем подготовительные ноты
                    }
                }

                // Финальную ноту делаем особенно яркой
                int finalBaseNote = ExtractBaseNoteValue(result[finalEmphasizedNote]);
                result[finalEmphasizedNote] = 2000 + finalBaseNote;
            }

            return result;
        }

        private List<int> ApplyGoaTranceVariations(List<int> bassLine)
        {
            var result = new List<int>(bassLine);

            // Goa Trance характеризуется психоделическими ритмическими паттернами,
            // с влиянием восточной музыки и непредсказуемыми органическими вариациями

            // 1. Добавляем характерные для Goa глиссандо и микро-скольжения
            for (int i = 0; i < result.Count; i++)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Микро-скольжения между нотами
                    if (i < result.Count - 1 && result[i + 1] > 0 && random.NextDouble() < 0.3)
                    {
                        result[i] = 4000 + baseNote; // Эффект скольжения
                    }

                    // Органические вариации с использованием слайдов
                    if (i % 4 == 3 && random.NextDouble() < 0.5)
                    {
                        result[i] = 4000 + baseNote; // Скольжение на конце фразы
                    }
                }
            }

            // 2. Создаем повторяющиеся паттерны с небольшими вариациями
            // Типичный для Goa прием - повторение мотива с небольшими изменениями
            if (random.NextDouble() < 0.7)
            {
                // Копируем часть паттерна с вариациями
                int sourceStart = random.Next(0, 4);
                int destStart = random.Next(8, 12);

                for (int i = 0; i < 4; i++)
                {
                    if (sourceStart + i < result.Count && destStart + i < result.Count)
                    {
                        if (result[sourceStart + i] > 0)
                        {
                            int baseNote = ExtractBaseNoteValue(result[sourceStart + i]);

                            // Вносим небольшие вариации в копию
                            if (random.NextDouble() < 0.5)
                            {
                                // Небольшой сдвиг ноты для органической вариации
                                result[destStart + i] = baseNote + (random.NextDouble() < 0.5 ? 1 : -1);
                            }
                            else
                            {
                                result[destStart + i] = baseNote;
                            }
                        }
                    }
                }
            }

            // 3. Характерные для Goa "органические" переходы
            for (int i = 6; i < 10; i++)
            {
                if (result[i] > 0 && random.NextDouble() < 0.4)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Создаем эффект "расщепления" ноты, типичный для психоделического Goa
                    if (i + 1 < result.Count && result[i + 1] == -1)
                    {
                        // Добавляем быструю дополнительную ноту сразу после
                        result[i + 1] = baseNote + (random.NextDouble() < 0.5 ? 2 : -2);
                    }
                }
            }

            // 4. Добавляем случайные акценты для создания трансового эффекта
            for (int i = 0; i < result.Count; i++)
            {
                if (result[i] > 0 && random.NextDouble() < 0.25)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);
                    result[i] = 2000 + baseNote; // Акцент
                }
            }

            return result;
        }

        private List<int> ApplyTechTranceVariations(List<int> bassLine)
        {
            var result = new List<int>(bassLine);

            // Tech Trance сочетает элементы техно и транса, с более механическими,
            // технически сложными паттернами и резкими контрастами

            // 1. Делаем атаку более резкой и четкой
            for (int i = 0; i < result.Count; i += 2)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Резкая атака с акцентом
                    if (random.NextDouble() < 0.6)
                    {
                        result[i] = 2000 + baseNote; // Акцентированная атака
                    }
                }
            }

            // 2. Добавляем характерные для Tech Trance паттерны "gate" эффекта
            for (int i = 1; i < result.Count; i += 4)
            {
                if (i + 2 < result.Count && result[i] == -1 && result[i + 1] == -1)
                {
                    // Находим базовую ноту для создания gate-эффекта
                    int referenceNote = -1;
                    for (int j = i - 1; j >= 0; j--)
                    {
                        if (result[j] > 0)
                        {
                            referenceNote = ExtractBaseNoteValue(result[j]);
                            break;
                        }
                    }

                    if (referenceNote > 0 && random.NextDouble() < 0.4)
                    {
                        // Создаем gate-эффект с быстрыми повторениями
                        result[i] = referenceNote;
                        result[i + 1] = -1; // Пауза
                    }
                }
            }

            // 3. Механические, "роботизированные" повторения
            if (random.NextDouble() < 0.6)
            {
                int patternStart = random.Next(0, 4);

                // Повторяем короткий паттерн несколько раз для механического эффекта
                int patternLength = 2; // Длина повторяющегося паттерна

                for (int repeat = 1; repeat < 3; repeat++)
                {
                    int destStart = patternStart + (repeat * patternLength);

                    for (int i = 0; i < patternLength; i++)
                    {
                        if (patternStart + i < result.Count && destStart + i < result.Count)
                        {
                            if (result[patternStart + i] > 0)
                            {
                                result[destStart + i] = result[patternStart + i];
                            }
                        }
                    }
                }
            }

            // 4. Резкие контрасты и переходы, типичные для Tech Trance
            for (int i = 7; i < 15; i += 8)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Создаем резкий переход
                    result[i] = 3000 + baseNote; // Тип артикуляции для резкого эффекта

                    // После резкого перехода - контраст
                    if (i + 1 < result.Count && result[i + 1] == -1)
                    {
                        // 50% шанс добавить неожиданную ноту после перехода
                        if (random.NextDouble() < 0.5)
                        {
                            result[i + 1] = baseNote + (random.NextDouble() < 0.5 ? 5 : -5);
                        }
                    }
                }
            }

            return result;
        }

        private List<int> ApplyProgressiveHouseVariations(List<int> bassLine)
        {
            var result = new List<int>(bassLine);

            // Progressive House характеризуется более мягкими, глубокими и гармоничными 
            // басовыми линиями, с плавными переходами и постепенным развитием

            // 1. Создаем более плавные переходы между нотами
            for (int i = 0; i < result.Count - 1; i++)
            {
                if (result[i] > 0 && result[i + 1] > 0)
                {
                    int currentNote = ExtractBaseNoteValue(result[i]);
                    int nextNote = ExtractBaseNoteValue(result[i + 1]);

                    // Если разница между нотами большая, добавляем плавный переход
                    if (Math.Abs(nextNote - currentNote) > 3 && random.NextDouble() < 0.6)
                    {
                        result[i] = 4000 + currentNote; // Плавный переход
                    }
                }
            }

            // 2. Добавляем более глубокие, продолжительные басовые ноты
            for (int i = 0; i < result.Count; i += 4)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // В Progressive House басовые ноты на сильных долях обычно более продолжительные
                    // Это имитируется путем создания более "массивного" звучания
                    if (random.NextDouble() < 0.7)
                    {
                        // Используем специальный эффект для передачи глубины
                        result[i] = 2000 + baseNote; // Более глубокая артикуляция

                        // Очищаем следующую позицию чтобы имитировать более длительную ноту
                        if (i + 1 < result.Count && result[i + 1] == -1)
                        {
                            continue; // Оставляем паузу для имитации продолжительности
                        }
                    }
                }
            }

            // 3. Характерные для Progressive House ритмические "кики"
            for (int i = 2; i < result.Count; i += 4)
            {
                if (result[i] == -1 && random.NextDouble() < 0.4)
                {
                    // Находим базовую ноту для создания "кика"
                    int referenceNote = -1;
                    for (int j = i - 1; j >= 0; j--)
                    {
                        if (result[j] > 0)
                        {
                            referenceNote = ExtractBaseNoteValue(result[j]);
                            break;
                        }
                    }

                    if (referenceNote > 0)
                    {
                        // Добавляем легкий "кик" - характерный для Progressive House
                        result[i] = referenceNote;
                    }
                }
            }

            // 4. Постепенное нарастание интенсивности к концу фразы
            // В Progressive House это делается очень плавно
            bool increasingIntensity = random.NextDouble() < 0.6;
            if (increasingIntensity)
            {
                for (int i = 8; i < 16; i++)
                {
                    if (result[i] > 0)
                    {
                        int baseNote = ExtractBaseNoteValue(result[i]);

                        // Чем ближе к концу, тем больше вероятность акцента
                        double accentProbability = 0.1 + ((i - 8) / 8.0) * 0.5;

                        if (random.NextDouble() < accentProbability)
                        {
                            result[i] = 2000 + baseNote; // Постепенно усиливающийся акцент
                        }
                    }
                }
            }

            return result;
        }

        private List<int> ApplyGenericTranceVariations(List<int> bassLine)
        {
            var result = new List<int>(bassLine);

            // Общие вариации, характерные для большинства стилей транса

            // 1. Добавляем стандартные транс-акценты
            for (int i = 0; i < result.Count; i += 4)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Акцент на сильной доле
                    if (random.NextDouble() < 0.7)
                    {
                        result[i] = 2000 + baseNote;
                    }
                }
            }

            // 2. Добавляем типичные для транса арпеджио-подобные эффекты
            for (int i = 0; i < result.Count - 2; i += 4)
            {
                if (result[i] > 0 && result[i + 1] == -1 && result[i + 2] == -1)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Создаем простой арпеджио паттерн
                    if (random.NextDouble() < 0.4)
                    {
                        result[i + 1] = baseNote + 5; // Добавляем квинту
                        result[i + 2] = baseNote + 7; // Добавляем септиму
                    }
                }
            }

            // 3. Скольжения между ключевыми нотами
            for (int i = 3; i < result.Count; i += 4)
            {
                if (result[i] > 0 && i + 1 < result.Count && result[i + 1] > 0)
                {
                    int currentNote = ExtractBaseNoteValue(result[i]);

                    // Скольжение к следующей ноте
                    if (random.NextDouble() < 0.5)
                    {
                        result[i] = 4000 + currentNote;
                    }
                }
            }

            // 4. Добавляем типичную для транса "пульсацию"
            for (int i = 1; i < result.Count; i += 2)
            {
                if (result[i] == -1 && i > 0 && result[i - 1] > 0)
                {
                    // С некоторой вероятностью добавляем "эхо" предыдущей ноты
                    if (random.NextDouble() < 0.3)
                    {
                        int previousNote = ExtractBaseNoteValue(result[i - 1]);
                        result[i] = previousNote;
                    }
                }
            }

            return result;
        }

        private static int[] ConvertToAbsoluteIntervals(List<int> cumulativeIntervals)
        {
            var absolute = new List<int> { 0 };
            for (int i = 0; i < cumulativeIntervals.Count; i++)
            {
                absolute.Add(absolute[i] + cumulativeIntervals[i]);
            }
            return absolute.ToArray();
        }

        private void InitializeTonicaComboBox()
        {
            cmbBoxTonica.Items.AddRange(new string[]
            {
                "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B",
                "Cm", "C#m", "Dm", "D#m", "Em", "Fm", "F#m", "Gm", "G#m", "Am", "A#m", "Bm"
            });
            cmbBoxTonica.SelectedIndex = 0;
        }

        private void InitializeCategoryComboBox()
        {
            cmbBoxCategory.Items.AddRange(scalesByCategory.Keys.OrderBy(c => c).ToArray());
            if (cmbBoxCategory.Items.Count > 0)
                cmbBoxCategory.SelectedIndex = 0;
        }

        private void InitializeScaleComboBox()
        {
            // Изначально заполняем первый раз после выбора категории
            UpdateScaleComboBox();
        }

        private void InitializeBassPatternComboBox()
        {
            cmbBoxBassPattern.Items.AddRange(bassPatterns.Keys.OrderBy(p => p).ToArray());
            if (cmbBoxBassPattern.Items.Count > 0)
                cmbBoxBassPattern.SelectedIndex = 0;
        }

        private void UpdateScaleComboBox()
        {
            cmbBoxScale.Items.Clear();
            string selectedCategory = cmbBoxCategory.SelectedItem?.ToString();

            if (!string.IsNullOrEmpty(selectedCategory) && scalesByCategory.TryGetValue(selectedCategory, out var scales))
            {
                cmbBoxScale.Items.AddRange(scales.Keys.OrderBy(s => s).ToArray());
            }

            if (cmbBoxScale.Items.Count > 0)
                cmbBoxScale.SelectedIndex = 0;
        }

        private void CmbBoxCategory_SelectedIndexChanged(object sender, EventArgs e)
        {
            UpdateScaleComboBox();
        }


        // Метод для проверки, принадлежит ли нота выбранному ладу
        private bool IsNoteInScale(int midiNote, List<int> scaleNotes)
        {
            // Normalize the note to the 0-11 range (octave-independent pitch class)
            int pitchClass = midiNote % 12;

            // Check if any scale note has the same pitch class
            return scaleNotes.Any(n => n % 12 == pitchClass);
        }
        
        private int FindClosestNoteInScale(int targetNote, List<int> scaleNotes)
        {
            // First, filter scale notes to those in a reasonable bass range
            var bassRangeScaleNotes = scaleNotes.Where(n => n >= 28 && n <= 55).ToList();

            if (bassRangeScaleNotes.Count == 0)
            {
                // Fallback to full scale notes if bass range is empty
                bassRangeScaleNotes = scaleNotes;
            }

            // First, try to find a note in the same octave
            var sameOctaveNotes = bassRangeScaleNotes
                .Where(n =>
                    (n % 12 == targetNote % 12) &&
                    Math.Abs(n - targetNote) < 12)
                .ToList();

            if (sameOctaveNotes.Any())
            {
                return sameOctaveNotes.OrderBy(n => Math.Abs(n - targetNote)).First();
            }

            // If no exact pitch class match, find the closest note
            return bassRangeScaleNotes
                .OrderBy(n => Math.Abs(n - targetNote))
                .First();
        }

        // Метод для генерации последовательности аккордов, подходящих для выбранной гаммы
        private List<KeyValuePair<string, string>> GenerateChordProgression(string tonica, string category, string scale, int count, List<int> scaleNotes)
        {
            bool isMinor = tonica.EndsWith("m");
            string root = isMinor ? tonica.Substring(0, tonica.Length - 1) : tonica;

            // Получаем аккорды, подходящие к гамме
            List<string> compatibleChordTypes = GetCompatibleChordTypes(category, scale, isMinor, scaleNotes);

            List<KeyValuePair<string, string>> progression = new List<KeyValuePair<string, string>>();

            // Начинаем с тоники
            progression.Add(new KeyValuePair<string, string>(root, isMinor ? "Minor" : "Major"));

            // Определяем диапазон нот для генерации аккордов
            var validRoots = noteOffsets.Where(x =>
                scaleNotes.Any(n => n % 12 == x.Value) &&
                x.Value != noteOffsets[root]
            ).Select(x => x.Key).ToList();

            // Если список валидных корней пуст, используем все ноты
            if (!validRoots.Any())
            {
                validRoots = noteOffsets.Keys.ToList();
            }

            // Генерируем остальные аккорды
            for (int i = 1; i < count; i++)
            {
                // Выбираем корень следующего аккорда из валидных нот
                string newRoot = validRoots[random.Next(validRoots.Count)];

                // Выбираем тип аккорда из совместимых
                string chordType = compatibleChordTypes[random.Next(compatibleChordTypes.Count)];

                progression.Add(new KeyValuePair<string, string>(newRoot, chordType));
            }

            return progression;
        }
        // Метод для получения типов аккордов, совместимых с выбранной гаммой
        private List<string> GetCompatibleChordTypes(string category, string scale, bool isMinor, List<int> scaleNotes)
        {
            // Базовые типы аккордов
            List<string> result = new List<string> { "Major", "Minor", "Major7", "Minor7", "Dominant7" };

            // Фильтруем типы аккордов, проверяя, что их ноты входят в гамму
            List<string> filteredTypes = new List<string>();

            foreach (var chordType in chordTypes.Keys)
            {
                // Для проверки используем базовую ноту тоники
                string rootNote = isMinor ? "A" : "C"; // Используем A для минора и C для мажора как базовые
                int rootMidi = isMinor ? 9 : 0; // MIDI номер для A или C

                // Получаем ноты аккорда
                int[] intervals = chordTypes[chordType];
                bool allNotesInScale = true;

                foreach (int interval in intervals)
                {
                    int noteMidi = (rootMidi + interval) % 12; // Приводим к одной октаве
                    if (!scaleNotes.Any(n => n % 12 == noteMidi))
                    {
                        allNotesInScale = false;
                        break;
                    }
                }

                if (allNotesInScale)
                {
                    filteredTypes.Add(chordType);
                }
            }

            // Если после фильтрации остались типы, используем их
            if (filteredTypes.Count > 0)
            {
                result = filteredTypes;
            }

            // Добавляем дополнительные типы в зависимости от гаммы
            if (scale.Contains("Major") || scale.Contains("Ionian"))
            {
                AddIfCompatible(result, new[] { "Major9", "Major13", "6", "Add9", "Quartal" }, scaleNotes, isMinor);
            }
            else if (scale.Contains("Minor") || scale.Contains("Aeolian"))
            {
                AddIfCompatible(result, new[] { "Minor9", "Minor11", "m6", "Half-Diminished7", "Diminished" }, scaleNotes, isMinor);
            }
            else if (scale.Contains("Dorian"))
            {
                AddIfCompatible(result, new[] { "Minor9", "Minor13", "m6", "Dominant9", "Quartal" }, scaleNotes, isMinor);
            }
            // Другие условия для разных ладов...

            return result;
        }

        // Вспомогательный метод для добавления совместимых типов аккордов
        private void AddIfCompatible(List<string> resultList, string[] typesToAdd, List<int> scaleNotes, bool isMinor)
        {
            string rootNote = isMinor ? "A" : "C";
            int rootMidi = isMinor ? 9 : 0;

            foreach (var type in typesToAdd)
            {
                if (!chordTypes.ContainsKey(type))
                    continue;

                int[] intervals = chordTypes[type];
                bool allNotesInScale = true;

                foreach (int interval in intervals)
                {
                    int noteMidi = (rootMidi + interval) % 12;
                    if (!scaleNotes.Any(n => n % 12 == noteMidi))
                    {
                        allNotesInScale = false;
                        break;
                    }
                }

                if (allNotesInScale && !resultList.Contains(type))
                {
                    resultList.Add(type);
                }
            }
        }

        // Метод для получения суффикса аккорда для отображения
        private string GetChordSuffix(string chordType)
        {
            switch (chordType)
            {
                case "Major": return "";
                case "Minor": return "m";
                case "Diminished": return "dim";
                case "Augmented": return "aug";
                case "Sus2": return "sus2";
                case "Sus4": return "sus4";
                case "Major7": return "maj7";
                case "Minor7": return "m7";
                case "Dominant7": return "7";
                case "Diminished7": return "dim7";
                case "Half-Diminished7": return "m7b5";
                case "Minor-Major7": return "mMaj7";
                case "Augmented7": return "aug7";
                case "Add9": return "add9";
                case "Add11": return "add11";
                case "Add13": return "add13";
                case "6": return "6";
                case "m6": return "m6";
                case "Major9": return "maj9";
                case "Minor9": return "m9";
                case "Dominant9": return "9";
                case "Major11": return "maj11";
                case "Minor11": return "m11";
                case "Dominant11": return "11";
                case "Major13": return "maj13";
                case "Minor13": return "m13";
                case "Dominant13": return "13";
                case "7b5": return "7b5";
                case "7#5": return "7#5";
                case "7b9": return "7b9";
                case "7#9": return "7#9";
                case "7#11": return "7#11";
                case "7b13": return "7b13";
                case "5": return "5";
                case "Quartal": return "quartal";
                default: return chordType;
            }
        }

        private void TxtNumeric_KeyPress(object sender, KeyPressEventArgs e)
        {
            if (!char.IsControl(e.KeyChar) && !char.IsDigit(e.KeyChar))
            {
                e.Handled = true;
            }
        }

        protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            // Если фокус на TextBox, пропускаем обработку клавиш хостом
            if (this.ActiveControl is TextBox)
            {
                return false;
            }
            return base.ProcessCmdKey(ref msg, keyData);
        }
        // Формируем строку с описанием MIDI-файла
        private string GenerateMidiDescription(List<List<int>> bassLine, List<KeyValuePair<string, string>> chordProgression)
        {
            StringBuilder description = new StringBuilder();

            description.AppendLine("Прогрессия аккордов:");
            for (int i = 0; i < chordProgression.Count; i++)
            {
                string chordName = chordProgression[i].Key + GetChordSuffix(chordProgression[i].Value);
                description.AppendLine($"Такт {i + 1}: {chordName}");
            }

            description.AppendLine("\nБасовая линия по тактам:");
            for (int i = 0; i < bassLine.Count; i++)
            {
                description.AppendLine($"Такт {i + 1}:");
                var measure = bassLine[i];

                // Группируем по четвертям для удобства чтения
                for (int beat = 0; beat < 4; beat++)
                {
                    List<string> beatNotes = new List<string>();
                    for (int pos = 0; pos < 4; pos++)
                    {
                        int index = beat * 4 + pos;
                        if (index < measure.Count)
                        {
                            int noteValue = measure[index];
                            if (noteValue > 0)
                            {
                                int baseNote = ExtractBaseNoteValue(noteValue);
                                string noteName = MidiNumberToNoteName(baseNote);

                                // Добавляем обозначение артикуляции, если есть
                                string articulation = "";
                                if (noteValue >= 4000) articulation = "(slide)";
                                else if (noteValue >= 3000) articulation = "(pull)";
                                else if (noteValue >= 2000) articulation = "(accent)";
                                else if (noteValue >= 1000) articulation = "(slap)";

                                beatNotes.Add(noteName + articulation);
                            }
                            else
                            {
                                beatNotes.Add("-");  // Пауза
                            }
                        }
                    }
                    description.AppendLine($"  Доля {beat + 1}: {string.Join(" ", beatNotes)}");
                }
            }

            return description.ToString();
        }
        private void btnGenerate_Click(object sender, EventArgs e)
        {
            string selectedTonica = cmbBoxTonica.SelectedItem.ToString();
            string selectedCategory = cmbBoxCategory.SelectedItem.ToString();
            string selectedScale = cmbBoxScale.SelectedItem.ToString();
            string selectedBassPattern = cmbBoxBassPattern.SelectedItem.ToString();
            int bassNotesCount;
            int uniqueMeasuresNumber;
            int repeatsNumber;

            bassNotesCount = (int)txtBassNotesCount.Value;
            uniqueMeasuresNumber = (int)txtTactsNumber.Value;
            repeatsNumber = (int)txtRepeatsNumber.Value;

            if (!scalesByCategory.ContainsKey(selectedCategory) || !scalesByCategory[selectedCategory].ContainsKey(selectedScale))
            {
                MessageBox.Show($"Гамма '{selectedScale}' в категории '{selectedCategory}' не поддерживается.", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            if (repeatsNumber > uniqueMeasuresNumber)
            {
                MessageBox.Show("Количество повторений не может превышать количество уникальных тактов.", "Ошибка ввода", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            try
            {
                int totalMeasuresNumber = uniqueMeasuresNumber + repeatsNumber;

                // Получаем ноты гаммы
                var scaleNotes = GetScaleNotes(selectedTonica, selectedCategory, selectedScale);

                if (scaleNotes.Count == 0)
                {
                    throw new Exception("Гамма не содержит нот.");
                }

                // Генерируем последовательность аккордов для басовой линии
                var chordProgression = GenerateChordProgression(selectedTonica, selectedCategory, selectedScale, uniqueMeasuresNumber, scaleNotes);

                // Генерируем уникальные такты на основе аккордов
                var uniqueMeasures = GenerateUniqueBassLines(selectedTonica, selectedCategory, selectedScale, selectedBassPattern, bassNotesCount, uniqueMeasuresNumber, chordProgression, scaleNotes);

                var repeatedMeasures = GenerateRepeatedMeasures(uniqueMeasures, repeatsNumber);
                var finalBassLine = CombineMeasures(uniqueMeasures, repeatedMeasures, totalMeasuresNumber);

                if (finalBassLine.Count > 0)
                {
                    // Создаем список для передачи в контрол отображения
                    List<int> notesToDisplay = new List<int>();

                    // Добавляем все ноты из всех тактов в один список
                    foreach (var measure in finalBassLine)
                    {
                        for (int i = 0; i < measure.Count; i++)
                        {
                            if (measure[i] > 0)
                            {
                                notesToDisplay.Add(ExtractBaseNoteValue(measure[i]));
                            }
                            else
                            {
                                notesToDisplay.Add(-1); // Паузы сохраняем как -1
                            }
                        }
                    }

                    // Сохраняем MIDI-файл и получаем путь
                    lastGeneratedMidiPath = SaveBassLineToMidi(finalBassLine, chordProgression,
                        selectedTonica, selectedScale, bassNotesCount);
                    _lastGeneratedMidiPath = lastGeneratedMidiPath;

                    // Формируем описание сгенерированного MIDI
                    string midiDescription = GenerateMidiDescription(finalBassLine, chordProgression);
                    txtProgression.Text = midiDescription;

                    // Включаем кнопку воспроизведения
                    btnPlayMidi.Enabled = true;

                    // Информируем пользователя
                    MessageBox.Show($"MIDI-файл успешно сохранен: {Path.GetFileName(lastGeneratedMidiPath)}",
                        "Успех", MessageBoxButtons.OK, MessageBoxIcon.Information);

                    // Устанавливаем ноты в контрол
                    noteDisplay.SetNotes(notesToDisplay);

                    // Прокручиваем контрол к началу, чтобы был виден первый такт
                    noteDisplay.ScrollToPosition(0);

                    // Принудительно перерисовываем
                    noteDisplay.Invalidate();
                    noteDisplay.Update();
                    Application.DoEvents();
                }
                else
                {
                    MessageBox.Show("Не удалось сгенерировать басовую линию.", "Предупреждение", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Произошла ошибка: {ex.Message}", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }
        private List<List<int>> GenerateRepeatedMeasures(List<List<int>> uniqueMeasures, int repeatsNumber)
        {
            var repeatedMeasures = new List<List<int>>();
            int uniqueCount = uniqueMeasures.Count;

            for (int i = 0; i < repeatsNumber; i++)
            {
                if (uniqueCount == 0)
                    break;

                int randomIndex = random.Next(uniqueCount);
                var measureToRepeat = uniqueMeasures[randomIndex];
                repeatedMeasures.Add(new List<int>(measureToRepeat));
            }

            return repeatedMeasures;
        }

        private List<List<int>> CombineMeasures(List<List<int>> uniqueMeasures, List<List<int>> repeatedMeasures, int totalMeasures)
        {
            var finalBassLine = new List<List<int>>(uniqueMeasures);

            foreach (var repeat in repeatedMeasures)
            {
                int insertPosition = random.Next(0, finalBassLine.Count + 1);
                finalBassLine.Insert(insertPosition, repeat);
            }

            // Проверяем, что количество тактов соответствует ожидаемому
            if (finalBassLine.Count != totalMeasures)
            {
                throw new Exception($"Количество тактов после генерации ({finalBassLine.Count}) не соответствует ожидаемому ({totalMeasures}).");
            }

            return finalBassLine;
        }

        // Метод для генерации уникальных басовых линий
        private List<List<int>> GenerateUniqueBassLines(string tonica, string category, string scale, string bassPatternName,
            int uniqueNotesCount, int uniqueMeasuresNumber, List<KeyValuePair<string, string>> chordProgression,
            List<int> scaleNotes)
        {
            var uniqueMeasures = new List<List<int>>();

            for (int i = 0; i < uniqueMeasuresNumber; i++)
            {
                // Get chord for this measure
                var currentChord = chordProgression[i % chordProgression.Count];
                string rootNote = currentChord.Key;
                string chordType = currentChord.Value;

                // Generate a measure based on current chord and pattern with rhythmic variation
                var measure = GenerateRhythmicBassLine(rootNote, chordType, bassPatternName, scaleNotes, uniqueNotesCount);

                // Проверка длины
                if (measure.Count != 16)
                {
                    // Исправляем длину, если необходимо
                    while (measure.Count < 16)
                        measure.Add(-1);
                    if (measure.Count > 16)
                        measure = measure.GetRange(0, 16);
                }

                // Add variations - передаем scaleNotes
                measure = AddEnhancedBassVariations(measure, scaleNotes, i);

                // Еще раз проверяем длину после вариаций
                if (measure.Count != 16)
                {
                    // Исправляем длину, если необходимо
                    while (measure.Count < 16)
                        measure.Add(-1);
                    if (measure.Count > 16)
                        measure = measure.GetRange(0, 16);
                }

                uniqueMeasures.Add(measure);
            }

            return uniqueMeasures;
        }
        private List<int[]> CreateRhythmicTemplates()
        {
            return new List<int[]>
    {
        // General Basic Patterns
        new int[] { 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0 }, // Quarter notes
        new int[] { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 }, // Eighth notes
        new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }, // Sixteenth notes

        // Jazz Patterns
        new int[] { 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0 }, // Jazz Walking Bass
        new int[] { 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1 }, // Jazz Syncopated
        new int[] { 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0 }, // Bebop Rhythm

        // Funk Patterns
        new int[] { 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0 }, // Funk Groove
        new int[] { 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0 }, // Slap Bass Funk
        new int[] { 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1 }, // Complex Funk

        // Rock Patterns
        new int[] { 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0 }, // Rock Power Chord
        new int[] { 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0 }, // Rock Shuffle
        new int[] { 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1 }, // Hard Rock Pulse

        // Reggae Patterns
        new int[] { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 }, // Reggae One Drop
        new int[] { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0 }, // Steppers Reggae
        new int[] { 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0 }, // Dub Rhythm

        // Electronic/Dance Patterns
        new int[] { 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0 }, // House
        new int[] { 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0 }, // Techno Pulse
        new int[] { 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1 }, // Breakbeat

        // Latin Patterns
        new int[] { 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0 }, // Salsa
        new int[] { 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0 }, // Bossa Nova
        new int[] { 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1 }, // Samba

        // Hip-Hop Patterns
        new int[] { 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0 }, // Old School Hip-Hop
        new int[] { 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 }, // Trap
        new int[] { 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0 }, // Modern Hip-Hop

        // Metal Patterns
        new int[] { 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1 }, // Thrash Metal
        new int[] { 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1 }, // Progressive Metal
        new int[] { 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0 }, // Technical Metal

        // Soul/R&B Patterns
        new int[] { 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0 }, // Smooth Soul
        new int[] { 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0 }, // R&B Groove
        new int[] { 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1 }, // Complex R&B

        // Fusion Patterns
        new int[] { 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1 }, // Jazz Fusion
        new int[] { 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1 }, // Ethnic Fusion
        new int[] { 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0 }  // Progressive Fusion
    };
        }
        // Метод для интеллектуального выбора ритмического шаблона на основе стиля
        private int[] SelectRhythmTemplate(string bassPatternName, List<int[]> rhythmicTemplates)
        {
            // Enhanced genre-specific rhythm mapping
            Dictionary<string, List<int>> genreRhythmIndices = new Dictionary<string, List<int>>(StringComparer.OrdinalIgnoreCase)
    {
        { "Jazz", new List<int> { 3, 4, 5 } },
        { "Bebop", new List<int> { 4, 5 } },
        { "Funk", new List<int> { 6, 7, 8 } },
        { "Soul", new List<int> { 6, 32, 33 } },
        { "R&B", new List<int> { 32, 33, 34 } },
        { "Reggae", new List<int> { 9, 10, 11 } },
        { "Dub", new List<int> { 10, 11 } },
        { "House", new List<int> { 15, 16 } },
        { "Techno", new List<int> { 15, 16 } },
        { "Rock", new List<int> { 12, 13, 14 } },
        { "Hard Rock", new List<int> { 13, 14 } },
        { "Metal", new List<int> { 35, 36, 37 } },
        { "Progressive Metal", new List<int> { 36, 37 } },
        { "Latin", new List<int> { 18, 19, 20 } },
        { "Salsa", new List<int> { 18 } },
        { "Bossa Nova", new List<int> { 19 } },
        { "Samba", new List<int> { 20 } },
        { "Hip-Hop", new List<int> { 21, 22, 23 } },
        { "Trap", new List<int> { 22 } },
        { "Fusion", new List<int> { 38, 39, 40 } },
        { "Electronic", new List<int> { 15, 16, 17 } },
        { "Breakbeat", new List<int> { 17 } }
    };

            // Look for perfect matches in genre-specific rhythm mappings
            foreach (var genre in genreRhythmIndices.Keys)
            {
                if (bassPatternName.IndexOf(genre, StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    var validIndices = genreRhythmIndices[genre];
                    return rhythmicTemplates[validIndices[random.Next(validIndices.Count)]];
                }
            }

            // Generic fallback - select a random template
            return rhythmicTemplates[random.Next(rhythmicTemplates.Count)];
        }
        private List<int> GeneratePossibleNotes(int baseNote, int[] chordNotes, int[] patternIntervals,
            List<int> scaleNotes, int uniqueNotesCount)
        {
            List<int> possibleNotes = new List<int>();

            // Add chord notes in the scale
            foreach (int interval in chordNotes)
            {
                int chordNote = baseNote + interval;
                if (IsNoteInScale(chordNote, scaleNotes) &&
                    chordNote >= 28 && chordNote <= 55 &&
                    !possibleNotes.Contains(chordNote))
                {
                    possibleNotes.Add(chordNote);
                }
            }

            // Add pattern-based notes
            foreach (int interval in patternIntervals)
            {
                int patternNote = baseNote + interval;
                if (IsNoteInScale(patternNote, scaleNotes) &&
                    patternNote >= 28 && patternNote <= 55 &&
                    !possibleNotes.Contains(patternNote))
                {
                    possibleNotes.Add(patternNote);
                }
            }

            // If not enough unique notes, supplement from scale
            while (possibleNotes.Count < uniqueNotesCount)
            {
                var additionalScaleNotes = scaleNotes
                    .Where(n => n >= 28 && n <= 55 && !possibleNotes.Contains(n))
                    .ToList();

                if (additionalScaleNotes.Count == 0)
                    break;

                possibleNotes.Add(additionalScaleNotes[random.Next(additionalScaleNotes.Count)]);
            }

            return possibleNotes;
        }
        private int ChooseNoteWithBias(List<int> possibleNotes, int baseNote, int[] chordIntervals)
        {
            // Создаем список нот аккорда для сравнения
            List<int> chordNotes = new List<int>();
            foreach (int interval in chordIntervals)
            {
                chordNotes.Add(baseNote + interval);
            }

            // С вероятностью 70% выбираем ноту аккорда, если она есть в возможных нотах
            if (random.NextDouble() < 0.7)
            {
                // Находим пересечение между возможными нотами и нотами аккорда
                var chordBasedNotes = possibleNotes.Where(n => chordNotes.Any(cn => n % 12 == cn % 12)).ToList();

                if (chordBasedNotes.Count > 0)
                {
                    // Выбираем случайную ноту из нот аккорда
                    return chordBasedNotes[random.Next(chordBasedNotes.Count)];
                }
            }

            // Если нет нот аккорда или не прошли вероятностный тест, выбираем случайную ноту
            return possibleNotes[random.Next(possibleNotes.Count)];
        }
        private List<int> GenerateRhythmicBassLine(string rootNote, string chordType, string bassPatternName,
            List<int> scaleNotes, int uniqueNotesCount)
        {
            // Always create a 16-element list initialized with a default note
            var measure = new int[16];
            for (int i = 0; i < 16; i++)
                measure[i] = -1; // Use -1 to indicate an empty slot

            // Get the root note's MIDI number on the first octave
            if (!noteOffsets.TryGetValue(rootNote, out int rootOffset))
            {
                rootOffset = 0; // Default to C
            }

            // Ensure we start exactly on the first octave
            int baseNote = 12 + rootOffset;

            // Ensure base note is in scale
            if (!IsNoteInScale(baseNote, scaleNotes))
            {
                baseNote = FindClosestNoteInScale(baseNote, scaleNotes);
            }

            // Get pattern and chord intervals
            int[] patternIntervals = bassPatterns[bassPatternName];
            var chordNotes = chordTypes.TryGetValue(chordType, out int[] intervals)
                ? intervals
                : new int[] { 0, 4, 7 };

            // First note is always the root note
            measure[0] = baseNote;

            // Get possible notes for this measure
            List<int> possibleNotes = GeneratePossibleNotes(baseNote, chordNotes, patternIntervals, scaleNotes, uniqueNotesCount);

            // Create rhythmic templates
            var rhythmicTemplates = CreateRhythmicTemplates();
            int[] selectedRhythm = SelectRhythmTemplate(bassPatternName, rhythmicTemplates);

            // Get style-specific durations
            var styleDurations = CreateStyleSpecificDurations();
            int[] noteDurations = null;

            // Find the most appropriate duration pattern for the current style
            foreach (var style in styleDurations.Keys)
            {
                if (bassPatternName.IndexOf(style, StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    noteDurations = styleDurations[style];
                    break;
                }
            }

            // If no specific style found, use default
            if (noteDurations == null)
            {
                noteDurations = styleDurations["Default"];
            }

            // Filter possible notes to only those in the scale and bass range
            var scaleCompatibleNotes = possibleNotes
                .Where(note =>
                    IsNoteInScale(note, scaleNotes) &&
                    note >= 28 && note <= 55)
                .ToList();

            // If no compatible notes, use scale notes in bass range
            if (scaleCompatibleNotes.Count == 0)
            {
                scaleCompatibleNotes = scaleNotes
                    .Where(n => n >= 28 && n <= 55)
                    .ToList();
            }

            // Store note durations in a separate list (will be used when creating MIDI)
            List<int> noteDurationValues = new List<int>();

            // First pass: Fill notes based on rhythmic template
            int noteCount = 1; // Start at 1 since first note is already set
            for (int i = 1; i < 16; i++) // Start from 1 to preserve the root note
            {
                if (selectedRhythm[i] == 1)
                {
                    // Preference for chord tones in the scale
                    var chordBasedNotes = scaleCompatibleNotes
                        .Where(n => chordNotes.Any(cn => (baseNote + cn) % 12 == n % 12) && n != baseNote)
                        .ToList();

                    int selectedNote;
                    if (chordBasedNotes.Any())
                    {
                        // Prefer chord tones
                        selectedNote = chordBasedNotes[random.Next(chordBasedNotes.Count)];
                    }
                    else
                    {
                        // Fall back to any scale-compatible note
                        var availableNotes = scaleCompatibleNotes.Where(n => n != baseNote).ToList();
                        if (availableNotes.Any())
                        {
                            selectedNote = availableNotes[random.Next(availableNotes.Count)];
                        }
                        else
                        {
                            // Emergency fallback if no other notes available
                            selectedNote = baseNote;
                        }
                    }

                    measure[i] = selectedNote;
                    noteCount++;
                }
            }

            // Second pass: Fill any remaining slots if needed based on the unique note count
            if (noteCount < uniqueNotesCount)
            {
                for (int i = 1; i < 16; i++) // Start from 1 to preserve the root note
                {
                    if (measure[i] == -1 && noteCount < uniqueNotesCount)
                    {
                        // Choose a note following scale and chord preferences
                        var chordBasedNotes = scaleCompatibleNotes
                            .Where(n => chordNotes.Any(cn => (baseNote + cn) % 12 == n % 12) && n != baseNote)
                            .ToList();

                        int selectedNote;
                        if (chordBasedNotes.Any())
                        {
                            selectedNote = chordBasedNotes[random.Next(chordBasedNotes.Count)];
                        }
                        else
                        {
                            var availableNotes = scaleCompatibleNotes.Where(n => n != baseNote).ToList();
                            if (availableNotes.Any())
                            {
                                selectedNote = availableNotes[random.Next(availableNotes.Count)];
                            }
                            else
                            {
                                // Emergency fallback
                                selectedNote = baseNote;
                            }
                        }

                        measure[i] = selectedNote;
                        noteCount++;
                    }
                }
            }

            // Store the pattern's note durations in a property to use when creating MIDI
            // Assuming you add a private field to store this:
            // private Dictionary<int, int> currentMeasureDurations = new Dictionary<int, int>();
            currentMeasureDurations.Clear();
            for (int i = 0; i < 16; i++)
            {
                if (measure[i] != -1)
                {
                    // Store the duration for this note position
                    currentMeasureDurations[i] = noteDurations[i];
                }
            }

            // Convert array to list
            var result = measure.ToList();

            // Add variations while maintaining scale compatibility
            return AddEnhancedBassVariations(result, scaleNotes, 0);
        }

        private Dictionary<int, int> currentMeasureDurations = new Dictionary<int, int>();
        private List<int> ApplyPsyTranceVars(List<int> bassLine, List<int> scaleNotes)
        {
            // Для PsyTrance: создаем новый басовый рисунок из 16 шестнадцатых нот без пауз
            List<int> result = new List<int>(new int[16]);

            // Находим базовую ноту (корень) для паттерна
            int baseNote = -1;
            for (int i = 0; i < bassLine.Count && i < 16; i++)
            {
                if (bassLine[i] > 0)
                {
                    baseNote = ExtractBaseNoteValue(bassLine[i]);
                    break;
                }
            }

            // Если базовая нота не найдена, используем нижнюю ноту из гаммы
            if (baseNote < 0 && scaleNotes.Count > 0)
            {
                baseNote = scaleNotes.Min();
            }
            else if (baseNote < 0)
            {
                baseNote = 28; // E1 как стандартная начальная нота баса
            }

            // Отфильтровываем ноты гаммы в басовом диапазоне
            List<int> bassScaleNotes = scaleNotes
                .Where(n => n >= 28 && n <= 55) // Диапазон баса
                .OrderBy(n => n)
                .ToList();

            // Если нет нот гаммы в басовом диапазоне, транспонируем гамму
            if (bassScaleNotes.Count == 0)
            {
                // Создаем базовую октаву и транспонируем ее в басовый диапазон
                List<int> baseOctave = scaleNotes.Where(n => n < 12).ToList();
                if (baseOctave.Count > 0)
                {
                    foreach (int note in baseOctave)
                    {
                        bassScaleNotes.Add(28 + note); // Транспонируем в E1 диапазон
                    }
                }
                else
                {
                    // Если гамма не найдена, создаем фригийский лад (типичный для psy)
                    bassScaleNotes = new List<int> { baseNote, baseNote + 1, baseNote + 3, baseNote + 5,
                                           baseNote + 7, baseNote + 8, baseNote + 10 };
                }
            }

            // Получаем корень, третью и пятую ступени гаммы для базовых арпеджио
            int root = bassScaleNotes.Contains(baseNote) ? baseNote :
                      bassScaleNotes.OrderBy(n => Math.Abs(n - baseNote)).First();

            // Находим третью ступень (может быть минорной или мажорной)
            int third = bassScaleNotes
                .Where(n => n > root && n <= root + 4)
                .OrderBy(n => Math.Abs((n - root) - 3)) // Предпочитаем минорную терцию (3 полутона)
                .FirstOrDefault();
            if (third == 0) third = root + 3; // Если не найдена, используем минорную

            // Находим пятую ступень
            int fifth = bassScaleNotes
                .Where(n => n > root && n <= root + 8)
                .OrderBy(n => Math.Abs((n - root) - 7)) // Ищем близкую к чистой квинте
                .FirstOrDefault();
            if (fifth == 0) fifth = root + 7; // Если не найдена, используем чистую квинту

            // Создаем характерные для PsyTrance ритмические паттерны БЕЗ ПАУЗ (все 16 нот заполнены)
            int[][] psyPatterns = new int[][]
            {
        // Классический 16th psy-bass pattern (все позиции заполнены)
        new int[] { root, root, third, root, root, root, fifth, root, root, root, third, root, root, root, fifth, root },
        
        // Вариант с более интенсивным синкопированным ритмом
        new int[] { root, third, third, root, fifth, fifth, root, third, root, root, fifth, third, third, root, fifth, fifth },
        
        // Arpeggio-pattern с движением вверх-вниз
        new int[] { root, third, fifth, third, root, third, fifth, third, root, third, fifth, third, root, third, fifth, third },
        
        // Секвенция с фокусом на квинту
        new int[] { root, fifth, fifth, root, root, fifth, fifth, fifth, root, fifth, fifth, root, root, fifth, root, fifth },
        
        // Типичный psy-trance "wobble" pattern
        new int[] { root, root+1, root, root-1, root, root+1, root, fifth, root, root+1, root, root-1, root, third, root, fifth },
        
        // Bouncy pattern (без пауз)
        new int[] { root, root, root, third, third, root, fifth, fifth, root, root, root, third, third, fifth, fifth, third },
        
        // Groovy pattern 
        new int[] { root, fifth, fifth, third, root, fifth, fifth, fifth, root, fifth, fifth, third, third, root, fifth, fifth },
        
        // Движение по интервалам (все ноты)
        new int[] { root, root+2, root, root+2, fifth, fifth-2, fifth, third, root, root+2, root, root+2, third, third+2, fifth, root },
        
        // Интенсивный pattern с непрерывным ритмом
        new int[] { root, third, root, fifth, root, third, root, fifth, root, third, root, fifth, root, third, root, fifth },
            };

            // Выбираем случайный паттерн из доступных
            int[] selectedPattern = psyPatterns[random.Next(psyPatterns.Length)];

            // Применяем выбранный паттерн, следя за тем, чтобы ноты были в гамме
            for (int i = 0; i < 16; i++)
            {
                int patternNote = selectedPattern[i];

                // Проверяем, есть ли нота в гамме (всегда должна быть ненулевая нота)
                if (!bassScaleNotes.Contains(patternNote))
                {
                    // Находим ближайшую ноту в гамме
                    patternNote = bassScaleNotes.OrderBy(n => Math.Abs(n - patternNote)).First();
                }

                // Применяем возможные артикуляции, характерные для PsyTrance
                double articulationChance = random.NextDouble();

                if (i % 4 == 0) // На сильных долях
                {
                    // Акцент на сильной доле (80% шанс)
                    if (articulationChance < 0.8)
                    {
                        result[i] = 2000 + patternNote; // Акцент (hammer-on эффект)
                    }
                    else
                    {
                        result[i] = patternNote;
                    }
                }
                else if (i % 2 == 0) // На второстепенных долях
                {
                    // Слайд перед сильной долей (40% шанс)
                    if (i < 15 && articulationChance < 0.4)
                    {
                        result[i] = 4000 + patternNote; // Slide эффект
                    }
                    // Стаккато эффект (30% шанс)
                    else if (articulationChance < 0.7)
                    {
                        result[i] = 1000 + patternNote; // Staccato/slap эффект
                    }
                    else
                    {
                        result[i] = patternNote;
                    }
                }
                else // На off-beat позициях
                {
                    // Стаккато эффект более вероятен (60% шанс)
                    if (articulationChance < 0.6)
                    {
                        result[i] = 1000 + patternNote; // Короткий staccato эффект
                    }
                    else
                    {
                        result[i] = patternNote;
                    }
                }
            }

            // Добавляем вариации к базовому паттерну без создания пауз
            ApplyPsyTranceVariationsWithoutPauses(result, bassScaleNotes);

            return result;
        }

        private void ApplyPsyTranceVariationsWithoutPauses(List<int> pattern, List<int> scaleNotes)
        {
            // Вероятность применения вариаций зависит от желаемой интенсивности
            double variationIntensity = 0.3 + (random.NextDouble() * 0.4); // 30-70% вариаций

            // Проходим по паттерну и добавляем вариации
            for (int i = 0; i < pattern.Count; i++)
            {
                int baseNote = ExtractBaseNoteValue(pattern[i]);

                // Определяем тип вариации для этой позиции
                if (random.NextDouble() < variationIntensity)
                {
                    double variationType = random.NextDouble();

                    // Глиссандо или "шквик" эффект
                    if (variationType < 0.3 && i % 4 == 3) // На конце каждой четвертки
                    {
                        pattern[i] = 4000 + baseNote; // Slide эффект
                    }

                    // Добавление ладовых вариаций (соседние ноты из гаммы)
                    else if (variationType < 0.6)
                    {
                        // Выбираем соседнюю ноту из гаммы
                        var neighborNotes = scaleNotes
                            .Where(n => Math.Abs(n - baseNote) <= 5 && n != baseNote)
                            .ToList();

                        if (neighborNotes.Any())
                        {
                            // Заменяем текущую ноту на соседнюю из гаммы
                            int newNote = neighborNotes[random.Next(neighborNotes.Count)];

                            // Сохраняем артикуляцию если она была
                            if (pattern[i] >= 4000)
                                pattern[i] = 4000 + newNote;
                            else if (pattern[i] >= 3000)
                                pattern[i] = 3000 + newNote;
                            else if (pattern[i] >= 2000)
                                pattern[i] = 2000 + newNote;
                            else if (pattern[i] >= 1000)
                                pattern[i] = 1000 + newNote;
                            else
                                pattern[i] = newNote;
                        }
                    }

                    // Gate-эффект (короткие прерывистые ноты)
                    else if (variationType < 0.9)
                    {
                        pattern[i] = 1000 + baseNote; // Staccato эффект
                    }
                }
            }
        }

        private void ApplyPsyTranceVariations(List<int> pattern, List<int> scaleNotes)
        {
            // Вероятность применения вариаций зависит от желаемой интенсивности
            double variationIntensity = 0.3 + (random.NextDouble() * 0.4); // 30-70% вариаций

            // Проходим по паттерну и добавляем вариации
            for (int i = 0; i < pattern.Count; i++)
            {
                // Пропускаем паузы
                if (pattern[i] <= 0) continue;

                int baseNote = ExtractBaseNoteValue(pattern[i]);

                // Определяем тип вариации для этой позиции
                if (random.NextDouble() < variationIntensity)
                {
                    double variationType = random.NextDouble();

                    // Note-repeat эффект (быстрое повторение ноты)
                    if (variationType < 0.3 && i < pattern.Count - 1 && pattern[i + 1] == -1)
                    {
                        pattern[i + 1] = baseNote;
                    }

                    // Глиссандо или "шквик" эффект
                    else if (variationType < 0.5 && i % 4 == 3) // На конце каждой четвертки
                    {
                        pattern[i] = 4000 + baseNote; // Slide эффект
                    }

                    // Добавление ладовых украшений (соседние ноты из гаммы)
                    else if (variationType < 0.7 && i < pattern.Count - 2)
                    {
                        // Выбираем соседнюю ноту из гаммы
                        var neighborNotes = scaleNotes
                            .Where(n => Math.Abs(n - baseNote) <= 5 && n != baseNote)
                            .ToList();

                        if (neighborNotes.Any() && pattern[i + 1] == -1)
                        {
                            pattern[i + 1] = neighborNotes[random.Next(neighborNotes.Count)];
                        }
                    }

                    // Gate-эффект (короткие прерывистые ноты)
                    else if (variationType < 0.9)
                    {
                        pattern[i] = 1000 + baseNote; // Staccato эффект
                    }
                }
            }
        }
        private List<int> ApplyProgressiveTranceVars(List<int> bassLine)
        {
            var result = new List<int>(bassLine);

            // Progressive Trance характеризуется постепенным нарастанием 
            // и усложнением паттерна к концу фразы

            // 1. Начинаем с простого паттерна в первой четверти
            for (int i = 0; i < 4; i++)
            {
                if (result[i] > 0)
                {
                    // Основная нота без изменений или с лёгкой артикуляцией
                    int baseNote = ExtractBaseNoteValue(result[i]);
                    result[i] = random.NextDouble() < 0.2 ? 2000 + baseNote : baseNote;
                }
            }

            // 2. Добавляем небольшие вариации во второй четверти
            for (int i = 4; i < 8; i++)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Иногда добавляем эффект скольжения для плавности
                    if (random.NextDouble() < 0.3)
                    {
                        result[i] = 4000 + baseNote; // Эффект скольжения
                    }
                    // Или делаем акцент
                    else if (random.NextDouble() < 0.4)
                    {
                        result[i] = 2000 + baseNote; // Акцент на ноте
                    }
                }
            }

            // 3. Третья четверть - более выраженные фильтр-свипы и вариации
            for (int i = 8; i < 12; i++)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Применяем более агрессивные артикуляции
                    if (random.NextDouble() < 0.5)
                    {
                        // Если следующая нота существует, создаем "свип" эффект
                        if (i < 11 && result[i + 1] > 0)
                        {
                            result[i] = 4000 + baseNote; // Скольжение к следующей ноте
                        }
                        else
                        {
                            result[i] = 2000 + baseNote; // Акцент
                        }
                    }
                }
            }

            // 4. Последняя четверть - кульминация с наиболее сложными вариациями
            for (int i = 12; i < 16; i++)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Финальные ноты с особыми эффектами
                    double variation = random.NextDouble();

                    if (variation < 0.3)
                    {
                        result[i] = 4000 + baseNote; // Скольжение
                    }
                    else if (variation < 0.6)
                    {
                        result[i] = 2000 + baseNote; // Акцент
                    }
                    else if (variation < 0.7)
                    {
                        // Добавляем тремоло-подобный эффект - очень короткие ноты
                        if (i < 15 && result[i + 1] == -1)
                        {
                            result[i + 1] = baseNote; // Повторяем ноту
                        }
                    }
                }
            }

            // 5. Типичный для прогрессив-транса эффект - фильтр-свип на кульминации
            if (random.NextDouble() < 0.7)
            {
                // Находим хорошую позицию для свипа - обычно пред-финальная нота
                for (int i = 14; i >= 12; i--)
                {
                    if (result[i] > 0)
                    {
                        int baseNote = ExtractBaseNoteValue(result[i]);
                        result[i] = 4000 + baseNote; // Эффект скольжения
                        break;
                    }
                }
            }

            return result;
        }

        private List<int> ApplyUpliftingTranceVars(List<int> bassLine)
        {
            var result = new List<int>(bassLine);

            // Uplifting Trance характеризуется ярко выраженными подъемами и спадами,
            // чистыми, энергичными нотами и особым вниманием к мелодии

            // 1. Сильные акценты на ключевых нотах
            for (int i = 0; i < result.Count; i += 4)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);
                    // Сильный акцент на каждой сильной доле
                    result[i] = 2000 + baseNote;
                }
            }

            // 2. Создаем "подъемы" для готовности к эйфорической кульминации
            // Обычно во второй половине такта
            for (int i = 8; i < 16; i++)
            {
                if (result[i] > 0 && result[i] < 1000)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Для нот на 3/4 такта добавляем специальный эффект "подъема"
                    if (i >= 12)
                    {
                        // Если следующая нота выше - добавляем скольжение
                        if (i < 15 && result[i + 1] > 0)
                        {
                            int nextBaseNote = ExtractBaseNoteValue(result[i + 1]);
                            if (nextBaseNote > baseNote)
                            {
                                result[i] = 4000 + baseNote; // Эффект скольжения вверх
                            }
                        }
                    }
                }
            }

            // 3. Характерное для Uplifting стаккато в ключевых точках 
            for (int i = 2; i < result.Count; i += 4)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Применяем стаккато и акцентированные ноты
                    if (random.NextDouble() < 0.6)
                    {
                        result[i] = 1000 + baseNote; // Стаккато-подобный эффект
                    }
                }
            }

            // 4. Добавляем характерное для апфлитинга нарастание к финалу
            int finalEmphasizedNote = -1;
            for (int i = 14; i >= 12; i--)
            {
                if (result[i] > 0)
                {
                    finalEmphasizedNote = i;
                    break;
                }
            }

            // Если нашли финальную ноту, создаем к ней подготовку
            if (finalEmphasizedNote > 0)
            {
                for (int i = finalEmphasizedNote - 2; i < finalEmphasizedNote; i++)
                {
                    if (i >= 0 && result[i] > 0)
                    {
                        int baseNote = ExtractBaseNoteValue(result[i]);
                        result[i] = 2000 + baseNote; // Акцентируем подготовительные ноты
                    }
                }

                // Финальную ноту делаем особенно яркой
                int finalBaseNote = ExtractBaseNoteValue(result[finalEmphasizedNote]);
                result[finalEmphasizedNote] = 2000 + finalBaseNote;
            }

            return result;
        }

        private List<int> ApplyGoaTranceVars(List<int> bassLine)
        {
            var result = new List<int>(bassLine);

            // Goa Trance характеризуется психоделическими ритмическими паттернами,
            // с влиянием восточной музыки и непредсказуемыми органическими вариациями

            // 1. Добавляем характерные для Goa глиссандо и микро-скольжения
            for (int i = 0; i < result.Count; i++)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Микро-скольжения между нотами
                    if (i < result.Count - 1 && result[i + 1] > 0 && random.NextDouble() < 0.3)
                    {
                        result[i] = 4000 + baseNote; // Эффект скольжения
                    }

                    // Органические вариации с использованием слайдов
                    if (i % 4 == 3 && random.NextDouble() < 0.5)
                    {
                        result[i] = 4000 + baseNote; // Скольжение на конце фразы
                    }
                }
            }

            // 2. Создаем повторяющиеся паттерны с небольшими вариациями
            // Типичный для Goa прием - повторение мотива с небольшими изменениями
            if (random.NextDouble() < 0.7)
            {
                // Копируем часть паттерна с вариациями
                int sourceStart = random.Next(0, 4);
                int destStart = random.Next(8, 12);

                for (int i = 0; i < 4; i++)
                {
                    if (sourceStart + i < result.Count && destStart + i < result.Count)
                    {
                        if (result[sourceStart + i] > 0)
                        {
                            int baseNote = ExtractBaseNoteValue(result[sourceStart + i]);

                            // Вносим небольшие вариации в копию
                            if (random.NextDouble() < 0.5)
                            {
                                // Небольшой сдвиг ноты для органической вариации
                                result[destStart + i] = baseNote + (random.NextDouble() < 0.5 ? 1 : -1);
                            }
                            else
                            {
                                result[destStart + i] = baseNote;
                            }
                        }
                    }
                }
            }

            // 3. Характерные для Goa "органические" переходы
            for (int i = 6; i < 10; i++)
            {
                if (result[i] > 0 && random.NextDouble() < 0.4)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Создаем эффект "расщепления" ноты, типичный для психоделического Goa
                    if (i + 1 < result.Count && result[i + 1] == -1)
                    {
                        // Добавляем быструю дополнительную ноту сразу после
                        result[i + 1] = baseNote + (random.NextDouble() < 0.5 ? 2 : -2);
                    }
                }
            }

            // 4. Добавляем случайные акценты для создания трансового эффекта
            for (int i = 0; i < result.Count; i++)
            {
                if (result[i] > 0 && random.NextDouble() < 0.25)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);
                    result[i] = 2000 + baseNote; // Акцент
                }
            }

            return result;
        }

        private List<int> ApplyTechTranceVars(List<int> bassLine)
        {
            var result = new List<int>(bassLine);

            // Tech Trance сочетает элементы техно и транса, с более механическими,
            // технически сложными паттернами и резкими контрастами

            // 1. Делаем атаку более резкой и четкой
            for (int i = 0; i < result.Count; i += 2)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Резкая атака с акцентом
                    if (random.NextDouble() < 0.6)
                    {
                        result[i] = 2000 + baseNote; // Акцентированная атака
                    }
                }
            }

            // 2. Добавляем характерные для Tech Trance паттерны "gate" эффекта
            for (int i = 1; i < result.Count; i += 4)
            {
                if (i + 2 < result.Count && result[i] == -1 && result[i + 1] == -1)
                {
                    // Находим базовую ноту для создания gate-эффекта
                    int referenceNote = -1;
                    for (int j = i - 1; j >= 0; j--)
                    {
                        if (result[j] > 0)
                        {
                            referenceNote = ExtractBaseNoteValue(result[j]);
                            break;
                        }
                    }

                    if (referenceNote > 0 && random.NextDouble() < 0.4)
                    {
                        // Создаем gate-эффект с быстрыми повторениями
                        result[i] = referenceNote;
                        result[i + 1] = -1; // Пауза
                    }
                }
            }

            // 3. Механические, "роботизированные" повторения
            if (random.NextDouble() < 0.6)
            {
                int patternStart = random.Next(0, 4);

                // Повторяем короткий паттерн несколько раз для механического эффекта
                int patternLength = 2; // Длина повторяющегося паттерна

                for (int repeat = 1; repeat < 3; repeat++)
                {
                    int destStart = patternStart + (repeat * patternLength);

                    for (int i = 0; i < patternLength; i++)
                    {
                        if (patternStart + i < result.Count && destStart + i < result.Count)
                        {
                            if (result[patternStart + i] > 0)
                            {
                                result[destStart + i] = result[patternStart + i];
                            }
                        }
                    }
                }
            }

            // 4. Резкие контрасты и переходы, типичные для Tech Trance
            for (int i = 7; i < 15; i += 8)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Создаем резкий переход
                    result[i] = 3000 + baseNote; // Тип артикуляции для резкого эффекта

                    // После резкого перехода - контраст
                    if (i + 1 < result.Count && result[i + 1] == -1)
                    {
                        // 50% шанс добавить неожиданную ноту после перехода
                        if (random.NextDouble() < 0.5)
                        {
                            result[i + 1] = baseNote + (random.NextDouble() < 0.5 ? 5 : -5);
                        }
                    }
                }
            }

            return result;
        }

        private List<int> ApplyProgressiveHouseVars(List<int> bassLine)
        {
            var result = new List<int>(bassLine);

            // Progressive House характеризуется более мягкими, глубокими и гармоничными 
            // басовыми линиями, с плавными переходами и постепенным развитием

            // 1. Создаем более плавные переходы между нотами
            for (int i = 0; i < result.Count - 1; i++)
            {
                if (result[i] > 0 && result[i + 1] > 0)
                {
                    int currentNote = ExtractBaseNoteValue(result[i]);
                    int nextNote = ExtractBaseNoteValue(result[i + 1]);

                    // Если разница между нотами большая, добавляем плавный переход
                    if (Math.Abs(nextNote - currentNote) > 3 && random.NextDouble() < 0.6)
                    {
                        result[i] = 4000 + currentNote; // Плавный переход
                    }
                }
            }

            // 2. Добавляем более глубокие, продолжительные басовые ноты
            for (int i = 0; i < result.Count; i += 4)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // В Progressive House басовые ноты на сильных долях обычно более продолжительные
                    // Это имитируется путем создания более "массивного" звучания
                    if (random.NextDouble() < 0.7)
                    {
                        // Используем специальный эффект для передачи глубины
                        result[i] = 2000 + baseNote; // Более глубокая артикуляция

                        // Очищаем следующую позицию чтобы имитировать более длительную ноту
                        if (i + 1 < result.Count && result[i + 1] == -1)
                        {
                            continue; // Оставляем паузу для имитации продолжительности
                        }
                    }
                }
            }

            // 3. Характерные для Progressive House ритмические "кики"
            for (int i = 2; i < result.Count; i += 4)
            {
                if (result[i] == -1 && random.NextDouble() < 0.4)
                {
                    // Находим базовую ноту для создания "кика"
                    int referenceNote = -1;
                    for (int j = i - 1; j >= 0; j--)
                    {
                        if (result[j] > 0)
                        {
                            referenceNote = ExtractBaseNoteValue(result[j]);
                            break;
                        }
                    }

                    if (referenceNote > 0)
                    {
                        // Добавляем легкий "кик" - характерный для Progressive House
                        result[i] = referenceNote;
                    }
                }
            }

            // 4. Постепенное нарастание интенсивности к концу фразы
            // В Progressive House это делается очень плавно
            bool increasingIntensity = random.NextDouble() < 0.6;
            if (increasingIntensity)
            {
                for (int i = 8; i < 16; i++)
                {
                    if (result[i] > 0)
                    {
                        int baseNote = ExtractBaseNoteValue(result[i]);

                        // Чем ближе к концу, тем больше вероятность акцента
                        double accentProbability = 0.1 + ((i - 8) / 8.0) * 0.5;

                        if (random.NextDouble() < accentProbability)
                        {
                            result[i] = 2000 + baseNote; // Постепенно усиливающийся акцент
                        }
                    }
                }
            }

            return result;
        }

        private List<int> ApplyGenericTranceVars(List<int> bassLine)
        {
            var result = new List<int>(bassLine);

            // Общие вариации, характерные для большинства стилей транса

            // 1. Добавляем стандартные транс-акценты
            for (int i = 0; i < result.Count; i += 4)
            {
                if (result[i] > 0)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Акцент на сильной доле
                    if (random.NextDouble() < 0.7)
                    {
                        result[i] = 2000 + baseNote;
                    }
                }
            }

            // 2. Добавляем типичные для транса арпеджио-подобные эффекты
            for (int i = 0; i < result.Count - 2; i += 4)
            {
                if (result[i] > 0 && result[i + 1] == -1 && result[i + 2] == -1)
                {
                    int baseNote = ExtractBaseNoteValue(result[i]);

                    // Создаем простой арпеджио паттерн
                    if (random.NextDouble() < 0.4)
                    {
                        result[i + 1] = baseNote + 5; // Добавляем квинту
                        result[i + 2] = baseNote + 7; // Добавляем септиму
                    }
                }
            }

            // 3. Скольжения между ключевыми нотами
            for (int i = 3; i < result.Count; i += 4)
            {
                if (result[i] > 0 && i + 1 < result.Count && result[i + 1] > 0)
                {
                    int currentNote = ExtractBaseNoteValue(result[i]);

                    // Скольжение к следующей ноте
                    if (random.NextDouble() < 0.5)
                    {
                        result[i] = 4000 + currentNote;
                    }
                }
            }

            // 4. Добавляем типичную для транса "пульсацию"
            for (int i = 1; i < result.Count; i += 2)
            {
                if (result[i] == -1 && i > 0 && result[i - 1] > 0)
                {
                    // С некоторой вероятностью добавляем "эхо" предыдущей ноты
                    if (random.NextDouble() < 0.3)
                    {
                        int previousNote = ExtractBaseNoteValue(result[i - 1]);
                        result[i] = previousNote;
                    }
                }
            }

            return result;
        }

        // Добавляем код для интеграции новых функций в метод ApplyStyleRhythmicVariations
        private List<int> ApplyStyleRhythmicVariations(List<int> bassLine, string style, List<int> scaleNotes)
        {
            // Проверяем сначала на PsyTrance - специальная функция для него
            if (style.IndexOf("PsyTrance", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyPsyTranceVars(bassLine, scaleNotes);
            }

            // Обычная проверка на другие транс-стили
            if (style.IndexOf("Progressive Trance", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyProgressiveTranceVars(bassLine);
            }
            else if (style.IndexOf("Uplifting Trance", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyUpliftingTranceVars(bassLine);
            }
            else if (style.IndexOf("Goa Trance", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyGoaTranceVars(bassLine);
            }
            else if (style.IndexOf("Tech Trance", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyTechTranceVars(bassLine);
            }
            else if (style.IndexOf("Progressive House", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyProgressiveHouseVars(bassLine);
            }
            else if (style.IndexOf("Trance", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyGenericTranceVars(bassLine);
            }
            // Новые расширенные функции жанров
            else if (style.IndexOf("Funk", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     style.IndexOf("Soul", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     style.IndexOf("R&B", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyFunkSoulRBVariations(bassLine, scaleNotes);
            }
            else if (style.IndexOf("Hip-Hop", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     style.IndexOf("Trap", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyHipHopTrapVariations(bassLine, scaleNotes);
            }
            else if (style.IndexOf("Rock", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     style.IndexOf("Metal", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyRockMetalVariations(bassLine, scaleNotes);
            }
            else if (style.IndexOf("Reggae", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     style.IndexOf("Dub", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyReggaeDubVariations(bassLine, scaleNotes);
            }
            else if (style.IndexOf("Jazz", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     style.IndexOf("Blues", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     style.IndexOf("Bebop", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyJazzBluesVariations(bassLine, scaleNotes);
            }
            else if (style.IndexOf("Latin", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     style.IndexOf("Salsa", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     style.IndexOf("Bossa Nova", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     style.IndexOf("Samba", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyLatinoVariations(bassLine, scaleNotes);
            }
            else if (style.IndexOf("House", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     style.IndexOf("Techno", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     style.IndexOf("Electro", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return ApplyElectronicVariations(bassLine, scaleNotes);
            }
            // Обратная совместимость с старыми функциями для неизвестных стилей
            else switch (style.ToLower())
                {
                    case "funk":
                    case "slap":
                        return ApplyFunkSoulRBVariations(bassLine, scaleNotes);

                    case "jazz":
                    case "walking bass":
                    case "bebop":
                        return ApplyJazzBluesVariations(bassLine, scaleNotes);

                    case "reggae":
                    case "dub":
                        return ApplyReggaeDubVariations(bassLine, scaleNotes);

                    case "metal":
                    case "thrash metal":
                        return ApplyRockMetalVariations(bassLine, scaleNotes);

                    case "house":
                    case "techno":
                        return ApplyElectronicVariations(bassLine, scaleNotes);

                    case "hip-hop":
                    case "trap":
                        return ApplyHipHopTrapVariations(bassLine, scaleNotes);

                    case "latin":
                    case "salsa":
                    case "bossa nova":
                        return ApplyLatinoVariations(bassLine, scaleNotes);

                    // Добавление специфических под-стилей для более точной обработки
                    case "disco":
                    case "future bass":
                    case "lo-fi":
                        return ApplyFunkSoulRBVariations(bassLine, scaleNotes);

                    case "dubstep":
                    case "drill":
                    case "grime":
                        return ApplyHipHopTrapVariations(bassLine, scaleNotes);

                    case "hard rock":
                    case "progressive metal":
                    case "grunge":
                    case "alternative":
                        return ApplyRockMetalVariations(bassLine, scaleNotes);

                    case "jazz waltz":
                    case "swing":
                    case "blues shuffle":
                        return ApplyJazzBluesVariations(bassLine, scaleNotes);

                    case "drum & bass":
                    case "breakbeat":
                    case "uk garage":
                        return ApplyElectronicVariations(bassLine, scaleNotes);

                    case "cumbia":
                    case "merengue":
                    case "afrobeat":
                        return ApplyLatinoVariations(bassLine, scaleNotes);

                    case "ska":
                    case "rocksteady":
                    case "dancehall":
                        return ApplyReggaeDubVariations(bassLine, scaleNotes);

                    default:
                        // Если стиль не определен, пытаемся определить по ключевым словам
                        if (style.Contains("Step") || style.Contains("Core") || style.Contains("Wave"))
                        {
                            return ApplyElectronicVariations(bassLine, scaleNotes);
                        }
                        else if (style.Contains("Rock") || style.Contains("Metal") || style.Contains("Punk"))
                        {
                            return ApplyRockMetalVariations(bassLine, scaleNotes);
                        }
                        else if (style.Contains("Folk") || style.Contains("Country") || style.Contains("Ethnic"))
                        {
                            // Для народной музыки часто используются простые, но выразительные басовые паттерны
                            return ApplyLatinoVariations(bassLine, scaleNotes); // Близко по характеру к народным
                        }
                        else if (style.Contains("Pop") || style.Contains("Indie"))
                        {
                            // Для поп-музыки характерны элементы фанка и R&B в басу
                            return ApplyFunkSoulRBVariations(bassLine, scaleNotes);
                        }
                        else if (style.Contains("Ambient") || style.Contains("Chill") || style.Contains("Downtempo"))
                        {
                            // Для эмбиента и чиллаута часто используется минималистичный бас
                            return ApplyElectronicVariations(bassLine, scaleNotes);
                        }

                        // Если никаких ключевых слов не найдено, оставляем как есть
                        return bassLine;
                }
        }
        private List<int> ApplyFunkVariations(List<int> bassLine)
        {
            // Funk is characterized by staccato notes and ghost notes
            var result = new List<int>(bassLine);

            // Randomly add slap articulation to notes (code 1000+)
            for (int i = 0; i < result.Count; i++)
            {
                if (result[i] > 0 && result[i] < 1000 && random.NextDouble() < 0.3)
                {
                    result[i] += 1000; // Add slap articulation
                }

                // Add ghost notes (note with very low velocity)
                if (result[i] == -1 && random.NextDouble() < 0.2)
                {
                    // Choose a nearby note from the bassline
                    int nearbyIndex = Math.Max(0, i - random.Next(1, 4));
                    if (result[nearbyIndex] > 0)
                    {
                        int baseNote = ExtractBaseNoteValue(result[nearbyIndex]);
                        result[i] = baseNote - 12; // Ghost note one octave lower
                    }
                }
            }

            return result;
        }

        private List<int> ApplyJazzVariations(List<int> bassLine)
        {
            // Jazz walking bass is characterized by smooth transitions and chromatic approaches
            var result = new List<int>(bassLine);

            // Add chromatic approaches to strong beats
            for (int i = 3; i < result.Count; i += 4)
            {
                if (result[i] > 0 && result[i + 1 < result.Count ? i + 1 : 0] > 0 && random.NextDouble() < 0.4)
                {
                    int currentNote = ExtractBaseNoteValue(result[i]);
                    int nextNote = ExtractBaseNoteValue(result[i + 1 < result.Count ? i + 1 : 0]);

                    // Chromatic approach from below or above
                    if (nextNote > currentNote && result[i - 1] == -1)
                    {
                        result[i - 1] = nextNote - 1; // Approach from a semitone below
                    }
                    else if (nextNote < currentNote && result[i - 1] == -1)
                    {
                        result[i - 1] = nextNote + 1; // Approach from a semitone above
                    }
                }
            }

            return result;
        }

        private List<int> ApplyReggaeVariations(List<int> bassLine)
        {
            // Reggae is characterized by emphasis on off-beats and space
            var result = new List<int>(bassLine);

            // Emphasize off-beats (2 and 4)
            for (int i = 0; i < result.Count; i++)
            {
                // Make space by removing some notes on downbeats
                if (i % 4 == 0 && result[i] > 0 && random.NextDouble() < 0.5)
                {
                    result[i] = -1; // Remove note
                }

                // Emphasize off-beats
                if ((i % 4 == 1 || i % 4 == 3) && result[i] == -1 && random.NextDouble() < 0.6)
                {
                    // Find a nearby note to use
                    for (int j = 1; j <= 4; j++)
                    {
                        int checkIndex = Math.Max(0, i - j);
                        if (result[checkIndex] > 0)
                        {
                            result[i] = ExtractBaseNoteValue(result[checkIndex]);
                            break;
                        }
                    }
                }
            }

            return result;
        }

        private List<int> ApplyMetalVariations(List<int> bassLine)
        {
            // Metal is characterized by palm muting and aggressive attacks
            var result = new List<int>(bassLine);

            // Add palm muting effect (represented by lower note with special articulation)
            for (int i = 0; i < result.Count; i++)
            {
                if (result[i] > 0 && random.NextDouble() < 0.4)
                {
                    // Palm mute - we'll use the pull-off articulation code (3000+) to represent this
                    int baseNote = ExtractBaseNoteValue(result[i]);
                    result[i] = 3000 + baseNote;
                }

                // Add aggressive attacks on strong beats
                if (i % 4 == 0 && result[i] > 0 && random.NextDouble() < 0.7)
                {
                    // Use hammer-on articulation (2000+) to represent aggressive attack
                    int baseNote = ExtractBaseNoteValue(result[i]);
                    result[i] = 2000 + baseNote;
                }
            }

            return result;
        }

        private List<int> ApplyElectronicVariations(List<int> bassLine)
        {
            // Electronic music is characterized by precise, quantized notes and repetitions
            var result = new List<int>(bassLine);

            // Create repetitive patterns
            if (random.NextDouble() < 0.5)
            {
                // Take first 4 or 8 notes and repeat them
                int patternLength = random.NextDouble() < 0.5 ? 4 : 8;
                for (int i = patternLength; i < result.Count; i++)
                {
                    if (i % patternLength < patternLength)
                    {
                        result[i] = result[i % patternLength];
                    }
                }
            }

            // Add filter sweep effect (gradually changing notes)
            if (random.NextDouble() < 0.3)
            {
                int startNote = -1;

                // Find a starting note
                for (int i = 0; i < result.Count; i++)
                {
                    if (result[i] > 0)
                    {
                        startNote = ExtractBaseNoteValue(result[i]);
                        break;
                    }
                }

                if (startNote > 0)
                {
                    // Apply gradual note changes
                    for (int i = 0; i < result.Count; i += 4)
                    {
                        if (result[i] > 0)
                        {
                            // Gradually move up or down
                            int direction = random.NextDouble() < 0.5 ? 1 : -1;
                            result[i] = startNote + (i / 4) * direction;
                        }
                    }
                }
            }

            return result;
        }
        private List<int> ApplyHipHopVariations(List<int> bassLine)
        {
            // Hip-hop is characterized by strong, sustained bass and 808-style effects
            var result = new List<int>(bassLine);

            // Apply sustained bass notes
            for (int i = 0; i < result.Count; i++)
            {
                if (result[i] > 0 && i % 4 == 0)
                {
                    // Make this a sustained note by clearing the next few positions
                    int sustainLength = random.Next(2, 4);
                    for (int j = 1; j <= sustainLength; j++)
                    {
                        if (i + j < result.Count)
                        {
                            result[i + j] = -1;
                        }
                    }
                }
            }

            // Add bass drops (sub bass)
            if (random.NextDouble() < 0.4)
            {
                // Find a good position for a bass drop
                int dropPosition = random.Next(4, 12);
                if (dropPosition < result.Count)
                {
                    // Get the root note and drop it an octave lower for sub bass
                    int rootNote = -1;
                    for (int i = 0; i < result.Count; i++)
                    {
                        if (result[i] > 0)
                        {
                            rootNote = ExtractBaseNoteValue(result[i]);
                            break;
                        }
                    }

                    if (rootNote > 0)
                    {
                        // Place the sub bass note
                        result[dropPosition] = rootNote - 12; // One octave lower

                        // Clear next positions for sustain
                        for (int i = 1; i <= 3; i++)
                        {
                            if (dropPosition + i < result.Count)
                            {
                                result[dropPosition + i] = -1;
                            }
                        }
                    }
                }
            }

            return result;
        }

        private List<int> ApplyLatinVariations(List<int> bassLine)
        {
            // Latin bass is characterized by syncopation and tumbao patterns
            var result = new List<int>(bassLine);

            // Classic tumbao pattern emphasizes specific beats
            int[] tumbaoEmphasis = { 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0 };

            for (int i = 0; i < result.Count; i++)
            {
                // Emphasize tumbao pattern beats
                if (tumbaoEmphasis[i % 16] == 1)
                {
                    // If there's no note here but should be emphasized in tumbao, add one
                    if (result[i] == -1)
                    {
                        // Find a nearby note to use
                        for (int j = 1; j <= 3; j++)
                        {
                            int checkIndex = Math.Max(0, i - j);
                            if (result[checkIndex] > 0)
                            {
                                result[i] = ExtractBaseNoteValue(result[checkIndex]);
                                break;
                            }
                        }
                    }
                    // If there's already a note, possibly add articulation
                    else if (result[i] > 0 && result[i] < 1000 && random.NextDouble() < 0.3)
                    {
                        // Add ghost note or slap articulation
                        if (random.NextDouble() < 0.5)
                        {
                            // Ghost note
                            result[i] = ExtractBaseNoteValue(result[i]) - 3;
                        }
                        else
                        {
                            // Slap articulation
                            result[i] += 1000;
                        }
                    }
                }
                // De-emphasize non-tumbao pattern beats
                else if (result[i] > 0 && random.NextDouble() < 0.4)
                {
                    // Remove some notes that don't fit the tumbao pattern
                    result[i] = -1;
                }
            }

            return result;
        }

        // Добавьте этот метод для применения стиль-специфичных артикуляций
        private List<int> ApplyStyleSpecificArticulations(List<int> bassLine, string style)
        {
            var result = new List<int>(bassLine);

            Dictionary<string, Func<int, int, bool, int>> styleArticulations = new Dictionary<string, Func<int, int, bool, int>>(StringComparer.OrdinalIgnoreCase)
    {
        // Каждая функция принимает (noteValue, position, isStrongBeat) и возвращает артикулированное значение ноты
        
        // Техники слэпа и фанка
        { "Funk", (note, pos, strong) =>
            strong ? (random.NextDouble() < 0.7 ? 1000 + note : note) :
                   (random.NextDouble() < 0.3 ? 1000 + note : note) },
        { "Slap", (note, pos, strong) =>
            strong ? (random.NextDouble() < 0.8 ? 1000 + note : note) :
                   (random.NextDouble() < 0.4 ? 1000 + note : note) },
                   
        // Техники джазового walking bass
        { "Jazz", (note, pos, strong) =>
            pos % 4 == 3 ? (random.NextDouble() < 0.4 ? 2000 + note : note) : note },
        { "Walking Bass", (note, pos, strong) =>
            pos % 4 == 3 ? (random.NextDouble() < 0.3 ? 2000 + note : note) : note },
            
        // Техники рока и метала
        { "Rock", (note, pos, strong) =>
            strong ? (random.NextDouble() < 0.2 ? 3000 + note : note) : note },
        { "Metal", (note, pos, strong) =>
            strong ? (random.NextDouble() < 0.5 ? 2000 + note : note) :
                   (random.NextDouble() < 0.3 ? 3000 + note : note) },
                   
        // Техники регги
        { "Reggae", (note, pos, strong) =>
            !strong ? (random.NextDouble() < 0.4 ? 3000 + note : note) : note },
            
        // По умолчанию: сохраняем оригинальную артикуляцию
        { "Default", (note, pos, strong) => note }
    };

            // Применяем артикуляции в зависимости от стиля
            Func<int, int, bool, int> articulationFunc = null;

            // Находим наиболее подходящий стиль
            foreach (var styleKey in styleArticulations.Keys)
            {
                if (style.IndexOf(styleKey, StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    articulationFunc = styleArticulations[styleKey];
                    break;
                }
            }

            // Если стиль не найден, используем умолчание
            if (articulationFunc == null)
            {
                articulationFunc = styleArticulations["Default"];
            }

            // Применяем артикуляции к нотам
            for (int i = 0; i < result.Count; i++)
            {
                if (result[i] > 0 && result[i] < 1000) // Применяем только к нотам без артикуляции
                {
                    bool isStrongBeat = i % 4 == 0;
                    result[i] = articulationFunc(result[i], i, isStrongBeat);
                }
            }

            return result;
        }

        // Добавьте этот метод для улучшения метода AddEnhancedBassVariations
        private List<int> AddEnhancedBassVariations(List<int> bassLine, List<int> scaleNotes, int measureIndex)
        {
            // Определяем стиль на основе названия паттерна из интерфейса
            string styleHint = "Default";
            if (cmbBoxBassPattern.SelectedItem != null)
            {
                styleHint = cmbBoxBassPattern.SelectedItem.ToString();
            }

            // Проверяем совместимость нот с гаммой
            for (int i = 0; i < bassLine.Count; i++)
            {
                int noteValue = bassLine[i];
                if (noteValue <= 0) continue; // Пропускаем паузы

                // Получаем базовое значение ноты (без артикуляции)
                int baseNoteValue = ExtractBaseNoteValue(noteValue);

                // Корректируем ноты, не входящие в гамму
                if (!IsNoteInScale(baseNoteValue, scaleNotes))
                {
                    int closestScaleNote = FindClosestNoteInScale(baseNoteValue, scaleNotes);

                    // Сохраняем артикуляцию
                    if (noteValue >= 4000)
                        bassLine[i] = 4000 + closestScaleNote;
                    else if (noteValue >= 3000)
                        bassLine[i] = 3000 + closestScaleNote;
                    else if (noteValue >= 2000)
                        bassLine[i] = 2000 + closestScaleNote;
                    else if (noteValue >= 1000)
                        bassLine[i] = 1000 + closestScaleNote;
                    else
                        bassLine[i] = closestScaleNote;
                }
            }

            // Применяем жанровые вариации на основе стиля
            List<int> result;

            // Проверяем сначала специфические трансовые стили
            if (styleHint.IndexOf("PsyTrance", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyPsyTranceVars(bassLine, scaleNotes);
            }
            else if (styleHint.IndexOf("Progressive Trance", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyProgressiveTranceVars(bassLine);
            }
            else if (styleHint.IndexOf("Uplifting Trance", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyUpliftingTranceVars(bassLine);
            }
            else if (styleHint.IndexOf("Goa Trance", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyGoaTranceVars(bassLine);
            }
            else if (styleHint.IndexOf("Tech Trance", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyTechTranceVars(bassLine);
            }
            else if (styleHint.IndexOf("Progressive House", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyProgressiveHouseVars(bassLine);
            }
            else if (styleHint.IndexOf("Trance", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyGenericTranceVars(bassLine);
            }
            // Теперь проверяем новые жанровые функции
            else if (styleHint.IndexOf("Funk", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     styleHint.IndexOf("Soul", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     styleHint.IndexOf("R&B", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyFunkSoulRBVariations(bassLine, scaleNotes);
            }
            else if (styleHint.IndexOf("Hip-Hop", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     styleHint.IndexOf("Trap", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyHipHopTrapVariations(bassLine, scaleNotes);
            }
            else if (styleHint.IndexOf("Rock", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     styleHint.IndexOf("Metal", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyRockMetalVariations(bassLine, scaleNotes);
            }
            else if (styleHint.IndexOf("Reggae", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     styleHint.IndexOf("Dub", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyReggaeDubVariations(bassLine, scaleNotes);
            }
            else if (styleHint.IndexOf("Jazz", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     styleHint.IndexOf("Blues", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     styleHint.IndexOf("Bebop", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyJazzBluesVariations(bassLine, scaleNotes);
            }
            else if (styleHint.IndexOf("Latin", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     styleHint.IndexOf("Salsa", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     styleHint.IndexOf("Bossa Nova", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     styleHint.IndexOf("Samba", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyLatinoVariations(bassLine, scaleNotes);
            }
            else if (styleHint.IndexOf("House", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     styleHint.IndexOf("Techno", StringComparison.OrdinalIgnoreCase) >= 0 ||
                     styleHint.IndexOf("Electro", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                result = ApplyElectronicVariations(bassLine, scaleNotes);
            }
            else
            {
                // Для не определенных стилей применяем обычные вариации
                result = bassLine;
            }

            // Применяем общие стиль-специфичные артикуляции
            result = ApplyStyleSpecificArticulations(result, styleHint);

            return result;
        }

        private string SaveBassLineToMidi(List<List<int>> bassLine, List<KeyValuePair<string, string>> chordProgression,
            string tonica, string scale, int bassNotesCount)
        {
            // Получаем путь к рабочему столу пользователя
            string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);

            // Формируем имя файла
            string baseChord = chordProgression[0].Key + GetChordSuffix(chordProgression[0].Value);
            baseChord = baseChord.Replace("#", "sharp").Replace("b", "flat");

            // Добавляем уникальный случайный номер к имени файла
            string randomNumber = random.Next(10000, 99999).ToString();
            string fileName = $"Bass_{tonica}_{scale}_{baseChord}_{randomNumber}.mid";
            string fullPath = Path.Combine(desktopPath, fileName);

            // Create MIDI file
            var midiFile = new MidiEventCollection(1, 480); // 480 ticks per quarter note
            int bpm = 100;
            int microsecondsPerQuarterNote = 60000000 / bpm;
            midiFile.AddEvent(new TempoEvent(microsecondsPerQuarterNote, 0), 0);

            int bassChannel = 1;

            // Set instrument
            midiFile.AddEvent(new PatchChangeEvent(0, bassChannel, 33), 0); // Finger Bass

            int currentTime = 0;
            int standardVelocity = 100; // Единый уровень громкости для всех нот

            // One sixteenth note is 1/4 of a quarter note tick
            int sixteenthNoteTicks = 120; // 480 / 4

            // Use a style-specific durations dictionary for the current pattern
            var styleDurations = CreateStyleSpecificDurations();

            // Add bass line
            int measureIndex = 0;
            foreach (var measure in bassLine)
            {
                // Use our stored durations if possible (these would be set during GenerateRhythmicBassLine)
                // Otherwise fall back to the default durations
                Dictionary<int, int> measureDurations = currentMeasureDurations.Count > 0
                    ? currentMeasureDurations
                    : new Dictionary<int, int>();

                for (int noteIndex = 0; noteIndex < 16; noteIndex++)
                {
                    int currentNoteValue = measure[noteIndex];

                    // Skip if no note at this position
                    if (currentNoteValue == -1)
                    {
                        currentTime += sixteenthNoteTicks;
                        continue;
                    }

                    // Извлекаем базовую ноту, убирая все коды артикуляции
                    int noteToPlay = ExtractBaseNoteValue(currentNoteValue);

                    // Проверка диапазона
                    noteToPlay = Clamp(noteToPlay, 28, 55);

                    // Get note duration - default to one sixteenth if not specified
                    int noteDuration = sixteenthNoteTicks;
                    if (measureDurations.ContainsKey(noteIndex))
                    {
                        // Convert relative duration value to actual ticks
                        noteDuration = measureDurations[noteIndex] * sixteenthNoteTicks;
                    }

                    // Make sure we have at least a minimum duration
                    noteDuration = Math.Max(sixteenthNoteTicks / 2, noteDuration);

                    // Добавляем только ноту, громкость и длительность, без специальных артикуляций
                    midiFile.AddEvent(new NoteOnEvent(currentTime, bassChannel, noteToPlay, standardVelocity, 0), 0);
                    midiFile.AddEvent(new NoteEvent(currentTime + noteDuration, bassChannel, MidiCommandCode.NoteOff, noteToPlay, 0), 0);

                    // Increment time by one sixteenth note
                    currentTime += sixteenthNoteTicks;
                }

                measureIndex++;
            }

            midiFile.AddEvent(new MetaEvent(MetaEventType.EndTrack, 0, currentTime), 0);
            MidiFile.Export(fullPath, midiFile);

            return fullPath;
        }
        private int ExtractBaseNoteValue(int codedNote)
        {
            if (codedNote >= 4000) return codedNote - 4000; // Слайд
            if (codedNote >= 3000 && codedNote < 4000) return codedNote - 3000; // Pull-off
            if (codedNote >= 2000 && codedNote < 3000) return codedNote - 2000; // Hammer-on
            if (codedNote >= 1000 && codedNote < 2000) return codedNote - 1000; // Слэп
            return codedNote; // Обычная нота
        }
       

        private string MidiNumberToNoteName(int midiNumber)
        {
            string[] notesSharp = { "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B" };
            int octave = (midiNumber / 12) - 1;
            int noteIndex = midiNumber % 12;
            return $"{notesSharp[noteIndex]}{octave}";
        }

        private List<int> GetScaleNotes(string tonica, string category, string scaleName)
        {
            var scaleIntervals = GetScaleIntervals(category, scaleName);
            if (scaleIntervals == null || scaleIntervals.Length == 0)
            {
                throw new Exception($"Гамма '{scaleName}' в категории '{category}' не имеет определенных интервалов.");
            }

            string baseNoteName = tonica.EndsWith("m") ? tonica.Substring(0, tonica.Length - 1) : tonica;
            if (!noteOffsets.ContainsKey(baseNoteName))
            {
                throw new Exception($"Нота '{baseNoteName}' не распознана.");
            }

            int noteOffsetValue = noteOffsets[baseNoteName];
            var scaleNotes = new List<int>();

            // Для баса используем октавы 1-3 (но можно настроить диапазон)
            for (int octave = 1; octave <= 3; octave++)
            {
                int baseMidi = 12 * octave + noteOffsetValue;
                foreach (var interval in scaleIntervals)
                {
                    int note = baseMidi + interval;
                    if (note >= 24 && note <= 59) // Полный диапазон бас-гитары
                    {
                        scaleNotes.Add(note);
                    }
                }
            }

            return scaleNotes.OrderBy(n => n).ToList();
        }

        private int[] GetScaleIntervals(string category, string scaleName)
        {
            if (scalesByCategory.ContainsKey(category) && scalesByCategory[category].ContainsKey(scaleName))
            {
                return scalesByCategory[category][scaleName];
            }
            else
            {
                // Попробуем поискать в других категориях
                foreach (var cat in scalesByCategory.Keys)
                {
                    if (scalesByCategory[cat].ContainsKey(scaleName))
                    {
                        return scalesByCategory[cat][scaleName];
                    }
                }

                throw new Exception($"Интервалы для гаммы '{scaleName}' не найдены ни в одной категории.");
            }
        }


        private int Clamp(int value, int min, int max)
        {
            if (value < min) return min;
            if (value > max) return max;
            return value;
        }


        // Добавьте эти методы в вашу форму BassGeneratorForm

        // Метод для обработки события изменения состояния радиокнопки Клавиатура
        private void rbKeyboard_CheckedChanged(object sender, System.EventArgs e)
        {
            if (rbKeyboard.Checked)
                noteDisplay.SetDisplayMode(0);
        }

        // Метод для обработки события изменения состояния радиокнопки Нотный стан
        private void rbStaff_CheckedChanged(object sender, System.EventArgs e)
        {
            if (rbStaff.Checked)
                noteDisplay.SetDisplayMode(1);
        }
        private void BassGeneratorForm_Resize(object sender, EventArgs e)
        {
            // Принудительно обновляем контрол отображения нот при изменении размера формы
            if (noteDisplay != null)
            {
                noteDisplay.Invalidate();
            }
        }
        // Метод для обновления отображения нот
        private void UpdateNoteDisplay(List<int> uniqueNotes)
        {
            // Проверяем, что контрол существует и есть ноты для отображения
            if (noteDisplay != null && uniqueNotes != null && uniqueNotes.Count > 0)
            {
                // Устанавливаем ноты
                noteDisplay.SetNotes(uniqueNotes);

                // Принудительно обновляем контрол
                noteDisplay.Invalidate();

                // Дополнительная логика для обработки критических случаев
                if (uniqueNotes.Count > 10)
                {
                    // Если слишком много нот, переключаемся в клавиатурный режим для лучшего отображения
                    rbKeyboard.Checked = true;
                }
            }
        }

        // ============ Методы для сохранения/восстановления состояния (для VST) ============

        public event EventHandler StateChanged;

        public int GetCategoryIndex()
        {
            return cmbBoxCategory.SelectedIndex;
        }

        public void SetCategoryIndex(int index)
        {
            if (index >= 0 && index < cmbBoxCategory.Items.Count)
            {
                cmbBoxCategory.SelectedIndex = index;
                OnStateChanged();
            }
        }

        public int GetScaleIndex()
        {
            return cmbBoxScale.SelectedIndex;
        }

        public void SetScaleIndex(int index)
        {
            if (index >= 0 && index < cmbBoxScale.Items.Count)
            {
                cmbBoxScale.SelectedIndex = index;
                OnStateChanged();
            }
        }

        public int GetTonicIndex()
        {
            return cmbBoxTonica.SelectedIndex;
        }

        public void SetTonicIndex(int index)
        {
            if (index >= 0 && index < cmbBoxTonica.Items.Count)
            {
                cmbBoxTonica.SelectedIndex = index;
                OnStateChanged();
            }
        }

        public int GetBassNotesCount()
        {
            return (int)txtBassNotesCount.Value;
        }

        public void SetBassNotesCount(int value)
        {
            txtBassNotesCount.Value = value;
            OnStateChanged();
        }

        public int GetTactsNumber()
        {
            return (int)txtTactsNumber.Value;
        }

        public void SetTactsNumber(int value)
        {
            txtTactsNumber.Value = value;
            OnStateChanged();
        }

        public int GetRepeatsNumber()
        {
            return (int)txtRepeatsNumber.Value;
        }

        public void SetRepeatsNumber(int value)
        {
            txtRepeatsNumber.Value = value;
            OnStateChanged();
        }

        public string GetGeneratedText()
        {
            return txtProgression.Text;
        }

        public void SetGeneratedText(string text)
        {
            txtProgression.Text = text;
        }

        private void OnStateChanged()
        {
            StateChanged?.Invoke(this, EventArgs.Empty);
        }

        // ============ Drag and Drop MIDI в DAW ============

        private void BtnDragMidi_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left && !string.IsNullOrEmpty(lastGeneratedMidiPath))
            {
                if (File.Exists(lastGeneratedMidiPath))
                {
                    // Создаем DataObject с путём к MIDI файлу
                    DataObject data = new DataObject();
                    data.SetData(DataFormats.FileDrop, new string[] { lastGeneratedMidiPath });
                    
                    // Запускаем операцию drag-and-drop
                    // Важно: используем btnPlayMidi, а не sender, чтобы кнопка не двигалась
                    DragDropEffects result = btnPlayMidi.DoDragDrop(data, DragDropEffects.Copy);
                    
                    if (result == DragDropEffects.Copy)
                    {
                        txtProgression.AppendText("\r\n✓ MIDI файл перетащен в DAW!");
                    }
                }
                else
                {
                    MessageBox.Show("Сначала сгенерируйте MIDI файл!", "Предупреждение", 
                                    MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
            }
        }

        private void btnPlayInDAW_Click(object sender, EventArgs e)
        {
            if (_plugin == null || _plugin.MidiProcessor == null)
            {
                MessageBox.Show("Плагин не инициализирован!", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            var midiPlayer = _plugin.MidiProcessor.MidiPlayer;

            if (midiPlayer.IsPlaying)
            {
                midiPlayer.Stop();
                ((System.Windows.Forms.Button)sender).Text = "▶ Воспроизвести в DAW";
                txtProgression.AppendText("\r\n⏹ Воспроизведение остановлено");
            }
            else
            {
                if (!string.IsNullOrEmpty(_lastGeneratedMidiPath) && File.Exists(_lastGeneratedMidiPath))
                {
                    try
                    {
                        midiPlayer.LoadMidiFile(_lastGeneratedMidiPath);
                        midiPlayer.SetSampleRate(44100);
                        midiPlayer.SetLoop(true);
                        midiPlayer.Play();
                        ((System.Windows.Forms.Button)sender).Text = "⏹ Остановить";
                        txtProgression.AppendText($"\r\n▶ Воспроизведение начато: {Path.GetFileName(_lastGeneratedMidiPath)}");
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Ошибка при воспроизведении MIDI: {ex.Message}", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
                else
                {
                    MessageBox.Show($"MIDI файл не найден!\nПуть: {_lastGeneratedMidiPath ?? "не задан"}", "Предупреждение", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
            }
        }

    }
}